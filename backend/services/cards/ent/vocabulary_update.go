



// Code generated by ent, DO NOT EDIT.



package ent



import (
	"context"
	"errors"
	"fmt"
	"math"
	"strings"
	"time"
		"sixels.io/manekani/services/cards/ent/predicate"
				"github.com/google/uuid"
			"github.com/jackc/pgtype"
			"github.com/jackc/pgtype"
			"github.com/jackc/pgtype"
			"github.com/google/uuid"
	"entgo.io/ent"
	"entgo.io/ent/dialect"
			"entgo.io/ent/dialect/sql"
			"entgo.io/ent/dialect/sql/sqlgraph"
			"entgo.io/ent/dialect/sql/sqljson"
			"entgo.io/ent/schema/field"

)


import (
		 "sixels.io/manekani/services/cards/ent/vocabulary"
		 "sixels.io/manekani/services/cards/ent/kanji"
)






// VocabularyUpdate is the builder for updating Vocabulary entities.
type VocabularyUpdate struct {
	config
	hooks []Hook
	mutation *VocabularyMutation
}

// Where appends a list predicates to the VocabularyUpdate builder.
func (vu *VocabularyUpdate) Where(ps ...predicate.Vocabulary) *VocabularyUpdate {
	vu.mutation.Where(ps...)
	return vu
}


	




	
	


	
	
	// SetUpdatedAt sets the "updated_at" field.
	func (vu *VocabularyUpdate) SetUpdatedAt(t time.Time) *VocabularyUpdate {
		vu.mutation.SetUpdatedAt(t)
		return vu
	}

	
	

	

	

	

	
	
	// SetName sets the "name" field.
	func (vu *VocabularyUpdate) SetName(s string) *VocabularyUpdate {
		vu.mutation.SetName(s)
		return vu
	}

	
	

	

	

	

	
	
	// SetAltNames sets the "alt_names" field.
	func (vu *VocabularyUpdate) SetAltNames(pa pgtype.TextArray) *VocabularyUpdate {
		vu.mutation.SetAltNames(pa)
		return vu
	}

	
	
		
		// SetNillableAltNames sets the "alt_names" field if the given value is not nil.
		func (vu *VocabularyUpdate) SetNillableAltNames(pa *pgtype.TextArray) *VocabularyUpdate {
			if pa != nil {
				vu.SetAltNames(*pa)
			}
			return vu
		}
	

	

	

	
		
		// ClearAltNames clears the value of the "alt_names" field.
		func (vu *VocabularyUpdate) ClearAltNames() *VocabularyUpdate {
			vu.mutation.ClearAltNames()
			return vu
		}
	

	
	
	// SetLevel sets the "level" field.
	func (vu *VocabularyUpdate) SetLevel(i int32) *VocabularyUpdate {
			vu.mutation.ResetLevel()
		vu.mutation.SetLevel(i)
		return vu
	}

	
	

	
		// AddLevel adds i to the "level" field.
		func (vu *VocabularyUpdate) AddLevel(i int32) *VocabularyUpdate {
			vu.mutation.AddLevel(i)
			return vu
		}
	

	

	

	
	
	// SetWord sets the "word" field.
	func (vu *VocabularyUpdate) SetWord(s string) *VocabularyUpdate {
		vu.mutation.SetWord(s)
		return vu
	}

	
	

	

	

	

	
	
	// SetWordType sets the "word_type" field.
	func (vu *VocabularyUpdate) SetWordType(pa pgtype.TextArray) *VocabularyUpdate {
		vu.mutation.SetWordType(pa)
		return vu
	}

	
	

	

	

	

	
	
	// SetReading sets the "reading" field.
	func (vu *VocabularyUpdate) SetReading(s string) *VocabularyUpdate {
		vu.mutation.SetReading(s)
		return vu
	}

	
	

	

	

	

	
	
	// SetAltReadings sets the "alt_readings" field.
	func (vu *VocabularyUpdate) SetAltReadings(pa pgtype.TextArray) *VocabularyUpdate {
		vu.mutation.SetAltReadings(pa)
		return vu
	}

	
	
		
		// SetNillableAltReadings sets the "alt_readings" field if the given value is not nil.
		func (vu *VocabularyUpdate) SetNillableAltReadings(pa *pgtype.TextArray) *VocabularyUpdate {
			if pa != nil {
				vu.SetAltReadings(*pa)
			}
			return vu
		}
	

	

	

	
		
		// ClearAltReadings clears the value of the "alt_readings" field.
		func (vu *VocabularyUpdate) ClearAltReadings() *VocabularyUpdate {
			vu.mutation.ClearAltReadings()
			return vu
		}
	

	
	
	// SetPatterns sets the "patterns" field.
	func (vu *VocabularyUpdate) SetPatterns(s []schema.Pattern) *VocabularyUpdate {
		vu.mutation.SetPatterns(s)
		return vu
	}

	
	

	

	
		// AppendPatterns appends s to the "patterns" field.
		func (vu *VocabularyUpdate) AppendPatterns(s []schema.Pattern) *VocabularyUpdate {
			vu.mutation.AppendPatterns(s)
			return vu
		}
	

	

	
	
	// SetSentences sets the "sentences" field.
	func (vu *VocabularyUpdate) SetSentences(s []schema.Sentence) *VocabularyUpdate {
		vu.mutation.SetSentences(s)
		return vu
	}

	
	

	

	
		// AppendSentences appends s to the "sentences" field.
		func (vu *VocabularyUpdate) AppendSentences(s []schema.Sentence) *VocabularyUpdate {
			vu.mutation.AppendSentences(s)
			return vu
		}
	

	

	
	
	// SetMeaningMnemonic sets the "meaning_mnemonic" field.
	func (vu *VocabularyUpdate) SetMeaningMnemonic(s string) *VocabularyUpdate {
		vu.mutation.SetMeaningMnemonic(s)
		return vu
	}

	
	

	

	

	

	
	
	// SetReadingMnemonic sets the "reading_mnemonic" field.
	func (vu *VocabularyUpdate) SetReadingMnemonic(s string) *VocabularyUpdate {
		vu.mutation.SetReadingMnemonic(s)
		return vu
	}

	
	

	

	

	



	
	
	
	
	
		// AddKanjiIDs adds the "kanjis" edge to the Kanji entity by IDs.
		func (vu *VocabularyUpdate) AddKanjiIDs(ids ... uuid.UUID) *VocabularyUpdate {
			vu.mutation.AddKanjiIDs(ids ...)
			return vu
		}
	
	
	
	
	
	// AddKanjis adds the "kanjis" edges to the Kanji entity.
	func (vu *VocabularyUpdate) AddKanjis(k ...*Kanji) *VocabularyUpdate {
		ids := make([]uuid.UUID, len(k))
			for i := range k {
				ids[i] = k[i].ID
			}
			return vu.AddKanjiIDs(ids...)
	}


// Mutation returns the VocabularyMutation object of the builder.
func (vu *VocabularyUpdate) Mutation() *VocabularyMutation {
	return vu.mutation
}





	





	
	
	// ClearKanjis clears all "kanjis" edges to the Kanji entity.
	func (vu *VocabularyUpdate) ClearKanjis() *VocabularyUpdate {
		vu.mutation.ClearKanjis()
		return vu
	}
	
		
		
		
		
		// RemoveKanjiIDs removes the "kanjis" edge to Kanji entities by IDs.
		func (vu *VocabularyUpdate) RemoveKanjiIDs(ids ...uuid.UUID) *VocabularyUpdate {
			vu.mutation.RemoveKanjiIDs(ids...)
			return vu
		}
		
		// RemoveKanjis removes "kanjis" edges to Kanji entities.
		func (vu *VocabularyUpdate) RemoveKanjis(k ...*Kanji) *VocabularyUpdate {
			ids := make([]uuid.UUID, len(k))
			for i := range k {
				ids[i] = k[i].ID
			}
			return vu.RemoveKanjiIDs(ids...)
		}
	




// Save executes the query and returns the number of nodes affected by the update operation.
func (vu *VocabularyUpdate) Save(ctx context.Context) (int, error) {
	var (
		err error
		affected int
	)
			vu.defaults()
	if len(vu.hooks) == 0 {
			if err = vu.check(); err != nil {
				return 0, err
			}
		affected, err = vu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*VocabularyMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
				if err = vu.check(); err != nil {
					return 0, err
				}
			vu.mutation = mutation
			affected, err = vu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(vu.hooks) - 1; i >= 0; i-- {
			if vu.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = vu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, vu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (vu *VocabularyUpdate) SaveX(ctx context.Context) int {
	affected, err := vu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (vu *VocabularyUpdate) Exec(ctx context.Context) error {
	_, err := vu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (vu *VocabularyUpdate) ExecX(ctx context.Context) {
	if err := vu.Exec(ctx); err != nil {
		panic(err)
	}
}


	







	// defaults sets the default values of the builder before save.
	func (vu *VocabularyUpdate) defaults() {
				if _, ok := vu.mutation.UpdatedAt(); !ok  {
					v := vocabulary.UpdateDefaultUpdatedAt()
					vu.mutation.SetUpdatedAt(v)
				}
	}



	// check runs all checks and user-defined validators on the builder.
	func (vu *VocabularyUpdate) check() error {
				if v, ok := vu.mutation.Name(); ok {
					if err := vocabulary.NameValidator(v); err != nil {
						return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.name": %w`, err)}
					}
				}
				if v, ok := vu.mutation.Level(); ok {
					if err := vocabulary.LevelValidator(v); err != nil {
						return &ValidationError{Name: "level", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.level": %w`, err)}
					}
				}
				if v, ok := vu.mutation.Word(); ok {
					if err := vocabulary.WordValidator(v); err != nil {
						return &ValidationError{Name: "word", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.word": %w`, err)}
					}
				}
				if v, ok := vu.mutation.Reading(); ok {
					if err := vocabulary.ReadingValidator(v); err != nil {
						return &ValidationError{Name: "reading", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.reading": %w`, err)}
					}
				}
				if v, ok := vu.mutation.MeaningMnemonic(); ok {
					if err := vocabulary.MeaningMnemonicValidator(v); err != nil {
						return &ValidationError{Name: "meaning_mnemonic", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.meaning_mnemonic": %w`, err)}
					}
				}
				if v, ok := vu.mutation.ReadingMnemonic(); ok {
					if err := vocabulary.ReadingMnemonicValidator(v); err != nil {
						return &ValidationError{Name: "reading_mnemonic", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.reading_mnemonic": %w`, err)}
					}
				}
		return nil
	}






	
	





    


func (vu *VocabularyUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table: vocabulary.Table,
			Columns: vocabulary.Columns,
				ID: &sqlgraph.FieldSpec{
					Type: field.TypeUUID,
					Column: vocabulary.FieldID,
				},
		},
	}
	if ps := vu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
				if value, ok := vu.mutation.UpdatedAt(); ok {
					_spec.SetField(vocabulary.FieldUpdatedAt, field.TypeTime, value)
				}
				if value, ok := vu.mutation.Name(); ok {
					_spec.SetField(vocabulary.FieldName, field.TypeString, value)
				}
				if value, ok := vu.mutation.AltNames(); ok {
					_spec.SetField(vocabulary.FieldAltNames, field.TypeOther, value)
				}
				if vu.mutation.AltNamesCleared() {
					_spec.ClearField(vocabulary.FieldAltNames, field.TypeOther)
				}
				if value, ok := vu.mutation.Level(); ok {
					_spec.SetField(vocabulary.FieldLevel, field.TypeInt32, value)
				}
					if value, ok := vu.mutation.AddedLevel(); ok {
						_spec.AddField(vocabulary.FieldLevel, field.TypeInt32, value)
					}
				if value, ok := vu.mutation.Word(); ok {
					_spec.SetField(vocabulary.FieldWord, field.TypeString, value)
				}
				if value, ok := vu.mutation.WordType(); ok {
					_spec.SetField(vocabulary.FieldWordType, field.TypeOther, value)
				}
				if value, ok := vu.mutation.Reading(); ok {
					_spec.SetField(vocabulary.FieldReading, field.TypeString, value)
				}
				if value, ok := vu.mutation.AltReadings(); ok {
					_spec.SetField(vocabulary.FieldAltReadings, field.TypeOther, value)
				}
				if vu.mutation.AltReadingsCleared() {
					_spec.ClearField(vocabulary.FieldAltReadings, field.TypeOther)
				}
				if value, ok := vu.mutation.Patterns(); ok {
					_spec.SetField(vocabulary.FieldPatterns, field.TypeJSON, value)
				}
					if value, ok := vu.mutation.AppendedPatterns(); ok {
						_spec.AddModifier(func(u *sql.UpdateBuilder) {
							sqljson.Append(u, vocabulary.FieldPatterns, value)
						})
					}
				if value, ok := vu.mutation.Sentences(); ok {
					_spec.SetField(vocabulary.FieldSentences, field.TypeJSON, value)
				}
					if value, ok := vu.mutation.AppendedSentences(); ok {
						_spec.AddModifier(func(u *sql.UpdateBuilder) {
							sqljson.Append(u, vocabulary.FieldSentences, value)
						})
					}
				if value, ok := vu.mutation.MeaningMnemonic(); ok {
					_spec.SetField(vocabulary.FieldMeaningMnemonic, field.TypeString, value)
				}
				if value, ok := vu.mutation.ReadingMnemonic(); ok {
					_spec.SetField(vocabulary.FieldReadingMnemonic, field.TypeString, value)
				}
		if vu.mutation.KanjisCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: false,
		Table: vocabulary.KanjisTable,
		Columns: vocabulary.KanjisPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeUUID,
				Column: kanji.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := vu.mutation.RemovedKanjisIDs(); len(nodes) > 0 && !vu.mutation.KanjisCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: false,
		Table: vocabulary.KanjisTable,
		Columns: vocabulary.KanjisPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeUUID,
				Column: kanji.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := vu.mutation.KanjisIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: false,
		Table: vocabulary.KanjisTable,
		Columns: vocabulary.KanjisPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeUUID,
				Column: kanji.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		if n, err = sqlgraph.UpdateNodes(ctx, vu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{ vocabulary.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	return n, nil
}







// VocabularyUpdateOne is the builder for updating a single Vocabulary entity.
type VocabularyUpdateOne struct {
	config
	fields []string
	hooks []Hook
	mutation *VocabularyMutation

}


	




	
	


	
	
	// SetUpdatedAt sets the "updated_at" field.
	func (vuo *VocabularyUpdateOne) SetUpdatedAt(t time.Time) *VocabularyUpdateOne {
		vuo.mutation.SetUpdatedAt(t)
		return vuo
	}

	
	

	

	

	

	
	
	// SetName sets the "name" field.
	func (vuo *VocabularyUpdateOne) SetName(s string) *VocabularyUpdateOne {
		vuo.mutation.SetName(s)
		return vuo
	}

	
	

	

	

	

	
	
	// SetAltNames sets the "alt_names" field.
	func (vuo *VocabularyUpdateOne) SetAltNames(pa pgtype.TextArray) *VocabularyUpdateOne {
		vuo.mutation.SetAltNames(pa)
		return vuo
	}

	
	
		
		// SetNillableAltNames sets the "alt_names" field if the given value is not nil.
		func (vuo *VocabularyUpdateOne) SetNillableAltNames(pa *pgtype.TextArray) *VocabularyUpdateOne {
			if pa != nil {
				vuo.SetAltNames(*pa)
			}
			return vuo
		}
	

	

	

	
		
		// ClearAltNames clears the value of the "alt_names" field.
		func (vuo *VocabularyUpdateOne) ClearAltNames() *VocabularyUpdateOne {
			vuo.mutation.ClearAltNames()
			return vuo
		}
	

	
	
	// SetLevel sets the "level" field.
	func (vuo *VocabularyUpdateOne) SetLevel(i int32) *VocabularyUpdateOne {
			vuo.mutation.ResetLevel()
		vuo.mutation.SetLevel(i)
		return vuo
	}

	
	

	
		// AddLevel adds i to the "level" field.
		func (vuo *VocabularyUpdateOne) AddLevel(i int32) *VocabularyUpdateOne {
			vuo.mutation.AddLevel(i)
			return vuo
		}
	

	

	

	
	
	// SetWord sets the "word" field.
	func (vuo *VocabularyUpdateOne) SetWord(s string) *VocabularyUpdateOne {
		vuo.mutation.SetWord(s)
		return vuo
	}

	
	

	

	

	

	
	
	// SetWordType sets the "word_type" field.
	func (vuo *VocabularyUpdateOne) SetWordType(pa pgtype.TextArray) *VocabularyUpdateOne {
		vuo.mutation.SetWordType(pa)
		return vuo
	}

	
	

	

	

	

	
	
	// SetReading sets the "reading" field.
	func (vuo *VocabularyUpdateOne) SetReading(s string) *VocabularyUpdateOne {
		vuo.mutation.SetReading(s)
		return vuo
	}

	
	

	

	

	

	
	
	// SetAltReadings sets the "alt_readings" field.
	func (vuo *VocabularyUpdateOne) SetAltReadings(pa pgtype.TextArray) *VocabularyUpdateOne {
		vuo.mutation.SetAltReadings(pa)
		return vuo
	}

	
	
		
		// SetNillableAltReadings sets the "alt_readings" field if the given value is not nil.
		func (vuo *VocabularyUpdateOne) SetNillableAltReadings(pa *pgtype.TextArray) *VocabularyUpdateOne {
			if pa != nil {
				vuo.SetAltReadings(*pa)
			}
			return vuo
		}
	

	

	

	
		
		// ClearAltReadings clears the value of the "alt_readings" field.
		func (vuo *VocabularyUpdateOne) ClearAltReadings() *VocabularyUpdateOne {
			vuo.mutation.ClearAltReadings()
			return vuo
		}
	

	
	
	// SetPatterns sets the "patterns" field.
	func (vuo *VocabularyUpdateOne) SetPatterns(s []schema.Pattern) *VocabularyUpdateOne {
		vuo.mutation.SetPatterns(s)
		return vuo
	}

	
	

	

	
		// AppendPatterns appends s to the "patterns" field.
		func (vuo *VocabularyUpdateOne) AppendPatterns(s []schema.Pattern) *VocabularyUpdateOne {
			vuo.mutation.AppendPatterns(s)
			return vuo
		}
	

	

	
	
	// SetSentences sets the "sentences" field.
	func (vuo *VocabularyUpdateOne) SetSentences(s []schema.Sentence) *VocabularyUpdateOne {
		vuo.mutation.SetSentences(s)
		return vuo
	}

	
	

	

	
		// AppendSentences appends s to the "sentences" field.
		func (vuo *VocabularyUpdateOne) AppendSentences(s []schema.Sentence) *VocabularyUpdateOne {
			vuo.mutation.AppendSentences(s)
			return vuo
		}
	

	

	
	
	// SetMeaningMnemonic sets the "meaning_mnemonic" field.
	func (vuo *VocabularyUpdateOne) SetMeaningMnemonic(s string) *VocabularyUpdateOne {
		vuo.mutation.SetMeaningMnemonic(s)
		return vuo
	}

	
	

	

	

	

	
	
	// SetReadingMnemonic sets the "reading_mnemonic" field.
	func (vuo *VocabularyUpdateOne) SetReadingMnemonic(s string) *VocabularyUpdateOne {
		vuo.mutation.SetReadingMnemonic(s)
		return vuo
	}

	
	

	

	

	



	
	
	
	
	
		// AddKanjiIDs adds the "kanjis" edge to the Kanji entity by IDs.
		func (vuo *VocabularyUpdateOne) AddKanjiIDs(ids ... uuid.UUID) *VocabularyUpdateOne {
			vuo.mutation.AddKanjiIDs(ids ...)
			return vuo
		}
	
	
	
	
	
	// AddKanjis adds the "kanjis" edges to the Kanji entity.
	func (vuo *VocabularyUpdateOne) AddKanjis(k ...*Kanji) *VocabularyUpdateOne {
		ids := make([]uuid.UUID, len(k))
			for i := range k {
				ids[i] = k[i].ID
			}
			return vuo.AddKanjiIDs(ids...)
	}


// Mutation returns the VocabularyMutation object of the builder.
func (vuo *VocabularyUpdateOne) Mutation() *VocabularyMutation {
	return vuo.mutation
}






	





	
	
	// ClearKanjis clears all "kanjis" edges to the Kanji entity.
	func (vuo *VocabularyUpdateOne) ClearKanjis() *VocabularyUpdateOne {
		vuo.mutation.ClearKanjis()
		return vuo
	}
	
		
		
		
		
		// RemoveKanjiIDs removes the "kanjis" edge to Kanji entities by IDs.
		func (vuo *VocabularyUpdateOne) RemoveKanjiIDs(ids ...uuid.UUID) *VocabularyUpdateOne {
			vuo.mutation.RemoveKanjiIDs(ids...)
			return vuo
		}
		
		// RemoveKanjis removes "kanjis" edges to Kanji entities.
		func (vuo *VocabularyUpdateOne) RemoveKanjis(k ...*Kanji) *VocabularyUpdateOne {
			ids := make([]uuid.UUID, len(k))
			for i := range k {
				ids[i] = k[i].ID
			}
			return vuo.RemoveKanjiIDs(ids...)
		}
	




// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (vuo *VocabularyUpdateOne) Select(field string, fields ...string) *VocabularyUpdateOne {
	vuo.fields = append([]string{field}, fields...)
	return vuo
}

// Save executes the query and returns the updated Vocabulary entity.
func (vuo *VocabularyUpdateOne ) Save(ctx context.Context) (*Vocabulary, error) {
	var (
		err error
		node *Vocabulary
	)
			vuo.defaults()
	if len(vuo.hooks) == 0 {
			if err = vuo.check(); err != nil {
				return nil, err
			}
		node, err = vuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*VocabularyMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
				if err = vuo.check(); err != nil {
					return nil, err
				}
			vuo.mutation = mutation
			node, err = vuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(vuo.hooks) - 1; i >= 0; i-- {
			if vuo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = vuo.hooks[i](mut)
		}
		v, err := mut.Mutate(ctx, vuo.mutation)
		if err != nil {
			return nil, err
		}
		nv, ok := v.(*Vocabulary)
		if !ok {
			return nil, fmt.Errorf("unexpected node type %T returned from VocabularyMutation", v)
		}
		node = nv
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (vuo *VocabularyUpdateOne) SaveX(ctx context.Context) *Vocabulary {
	node, err := vuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (vuo *VocabularyUpdateOne) Exec(ctx context.Context) error {
	_, err := vuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (vuo *VocabularyUpdateOne) ExecX(ctx context.Context) {
	if err := vuo.Exec(ctx); err != nil {
		panic(err)
	}
}


	







	// defaults sets the default values of the builder before save.
	func (vuo *VocabularyUpdateOne) defaults() {
				if _, ok := vuo.mutation.UpdatedAt(); !ok  {
					v := vocabulary.UpdateDefaultUpdatedAt()
					vuo.mutation.SetUpdatedAt(v)
				}
	}



	// check runs all checks and user-defined validators on the builder.
	func (vuo *VocabularyUpdateOne) check() error {
				if v, ok := vuo.mutation.Name(); ok {
					if err := vocabulary.NameValidator(v); err != nil {
						return &ValidationError{Name: "name", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.name": %w`, err)}
					}
				}
				if v, ok := vuo.mutation.Level(); ok {
					if err := vocabulary.LevelValidator(v); err != nil {
						return &ValidationError{Name: "level", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.level": %w`, err)}
					}
				}
				if v, ok := vuo.mutation.Word(); ok {
					if err := vocabulary.WordValidator(v); err != nil {
						return &ValidationError{Name: "word", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.word": %w`, err)}
					}
				}
				if v, ok := vuo.mutation.Reading(); ok {
					if err := vocabulary.ReadingValidator(v); err != nil {
						return &ValidationError{Name: "reading", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.reading": %w`, err)}
					}
				}
				if v, ok := vuo.mutation.MeaningMnemonic(); ok {
					if err := vocabulary.MeaningMnemonicValidator(v); err != nil {
						return &ValidationError{Name: "meaning_mnemonic", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.meaning_mnemonic": %w`, err)}
					}
				}
				if v, ok := vuo.mutation.ReadingMnemonic(); ok {
					if err := vocabulary.ReadingMnemonicValidator(v); err != nil {
						return &ValidationError{Name: "reading_mnemonic", err: fmt.Errorf(`ent: validator failed for field "Vocabulary.reading_mnemonic": %w`, err)}
					}
				}
		return nil
	}






	
	





    


func (vuo *VocabularyUpdateOne) sqlSave(ctx context.Context) (_node *Vocabulary, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table: vocabulary.Table,
			Columns: vocabulary.Columns,
				ID: &sqlgraph.FieldSpec{
					Type: field.TypeUUID,
					Column: vocabulary.FieldID,
				},
		},
	}
			id, ok := vuo.mutation.ID()
			if !ok {
				return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Vocabulary.id" for update`)}
			}
			_spec.Node.ID.Value = id
			if fields := vuo.fields; len(fields) > 0 {
				_spec.Node.Columns = make([]string, 0, len(fields))
				_spec.Node.Columns = append(_spec.Node.Columns, vocabulary.FieldID)
				for _, f := range fields {
					if !vocabulary.ValidColumn(f) {
						return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
					}
					if f != vocabulary.FieldID {
						_spec.Node.Columns = append(_spec.Node.Columns, f)
					}
				}
			}
	if ps := vuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
				if value, ok := vuo.mutation.UpdatedAt(); ok {
					_spec.SetField(vocabulary.FieldUpdatedAt, field.TypeTime, value)
				}
				if value, ok := vuo.mutation.Name(); ok {
					_spec.SetField(vocabulary.FieldName, field.TypeString, value)
				}
				if value, ok := vuo.mutation.AltNames(); ok {
					_spec.SetField(vocabulary.FieldAltNames, field.TypeOther, value)
				}
				if vuo.mutation.AltNamesCleared() {
					_spec.ClearField(vocabulary.FieldAltNames, field.TypeOther)
				}
				if value, ok := vuo.mutation.Level(); ok {
					_spec.SetField(vocabulary.FieldLevel, field.TypeInt32, value)
				}
					if value, ok := vuo.mutation.AddedLevel(); ok {
						_spec.AddField(vocabulary.FieldLevel, field.TypeInt32, value)
					}
				if value, ok := vuo.mutation.Word(); ok {
					_spec.SetField(vocabulary.FieldWord, field.TypeString, value)
				}
				if value, ok := vuo.mutation.WordType(); ok {
					_spec.SetField(vocabulary.FieldWordType, field.TypeOther, value)
				}
				if value, ok := vuo.mutation.Reading(); ok {
					_spec.SetField(vocabulary.FieldReading, field.TypeString, value)
				}
				if value, ok := vuo.mutation.AltReadings(); ok {
					_spec.SetField(vocabulary.FieldAltReadings, field.TypeOther, value)
				}
				if vuo.mutation.AltReadingsCleared() {
					_spec.ClearField(vocabulary.FieldAltReadings, field.TypeOther)
				}
				if value, ok := vuo.mutation.Patterns(); ok {
					_spec.SetField(vocabulary.FieldPatterns, field.TypeJSON, value)
				}
					if value, ok := vuo.mutation.AppendedPatterns(); ok {
						_spec.AddModifier(func(u *sql.UpdateBuilder) {
							sqljson.Append(u, vocabulary.FieldPatterns, value)
						})
					}
				if value, ok := vuo.mutation.Sentences(); ok {
					_spec.SetField(vocabulary.FieldSentences, field.TypeJSON, value)
				}
					if value, ok := vuo.mutation.AppendedSentences(); ok {
						_spec.AddModifier(func(u *sql.UpdateBuilder) {
							sqljson.Append(u, vocabulary.FieldSentences, value)
						})
					}
				if value, ok := vuo.mutation.MeaningMnemonic(); ok {
					_spec.SetField(vocabulary.FieldMeaningMnemonic, field.TypeString, value)
				}
				if value, ok := vuo.mutation.ReadingMnemonic(); ok {
					_spec.SetField(vocabulary.FieldReadingMnemonic, field.TypeString, value)
				}
		if vuo.mutation.KanjisCleared() {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: false,
		Table: vocabulary.KanjisTable,
		Columns: vocabulary.KanjisPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeUUID,
				Column: kanji.FieldID,
			},
		},
	}
			_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
		}
			if nodes := vuo.mutation.RemovedKanjisIDs(); len(nodes) > 0 && !vuo.mutation.KanjisCleared() {
					edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: false,
		Table: vocabulary.KanjisTable,
		Columns: vocabulary.KanjisPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeUUID,
				Column: kanji.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
				_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
			}
		if nodes := vuo.mutation.KanjisIDs(); len(nodes) > 0 {
				edge := &sqlgraph.EdgeSpec{
		Rel: sqlgraph.M2M,
		Inverse: false,
		Table: vocabulary.KanjisTable,
		Columns: vocabulary.KanjisPrimaryKey,
		Bidi: false,
		Target: &sqlgraph.EdgeTarget{
			IDSpec: &sqlgraph.FieldSpec{
				Type: field.TypeUUID,
				Column: kanji.FieldID,
			},
		},
	}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
			_spec.Edges.Add = append(_spec.Edges.Add, edge)
		}
		_node = &Vocabulary{config: vuo.config}
		_spec.Assign = _node.assignValues
		_spec.ScanValues = _node.scanValues
		if err = sqlgraph.UpdateNode(ctx, vuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{ vocabulary.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	return _node, nil
}



