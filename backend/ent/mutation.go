// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"sixels.io/manekani/core/domain/cards"
	"sixels.io/manekani/ent/apitoken"
	"sixels.io/manekani/ent/card"
	"sixels.io/manekani/ent/deck"
	"sixels.io/manekani/ent/deckprogress"
	"sixels.io/manekani/ent/predicate"
	"sixels.io/manekani/ent/review"
	"sixels.io/manekani/ent/schema"
	"sixels.io/manekani/ent/subject"
	"sixels.io/manekani/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApiToken     = "ApiToken"
	TypeCard         = "Card"
	TypeDeck         = "Deck"
	TypeDeckProgress = "DeckProgress"
	TypeReview       = "Review"
	TypeSubject      = "Subject"
	TypeUser         = "User"
)

// ApiTokenMutation represents an operation that mutates the ApiToken nodes in the graph.
type ApiTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	token         *[]byte
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ApiToken, error)
	predicates    []predicate.ApiToken
}

var _ ent.Mutation = (*ApiTokenMutation)(nil)

// apitokenOption allows management of the mutation configuration using functional options.
type apitokenOption func(*ApiTokenMutation)

// newApiTokenMutation creates new mutation for the ApiToken entity.
func newApiTokenMutation(c config, op Op, opts ...apitokenOption) *ApiTokenMutation {
	m := &ApiTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeApiToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiTokenID sets the ID field of the mutation.
func withApiTokenID(id uuid.UUID) apitokenOption {
	return func(m *ApiTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiToken
		)
		m.oldValue = func(ctx context.Context) (*ApiToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiToken sets the old ApiToken of the mutation.
func withApiToken(node *ApiToken) apitokenOption {
	return func(m *ApiTokenMutation) {
		m.oldValue = func(context.Context) (*ApiToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiToken entities.
func (m *ApiTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *ApiTokenMutation) SetToken(b []byte) {
	m.token = &b
}

// Token returns the value of the "token" field in the mutation.
func (m *ApiTokenMutation) Token() (r []byte, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldToken(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *ApiTokenMutation) ResetToken() {
	m.token = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ApiTokenMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApiTokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApiTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ApiTokenMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApiTokenMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApiTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ApiTokenMutation builder.
func (m *ApiTokenMutation) Where(ps ...predicate.ApiToken) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ApiTokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ApiToken).
func (m *ApiTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiTokenMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.token != nil {
		fields = append(fields, apitoken.FieldToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldToken:
		return m.Token()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apitoken.FieldToken:
		return m.OldToken(ctx)
	}
	return nil, fmt.Errorf("unknown ApiToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldToken:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	}
	return fmt.Errorf("unknown ApiToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApiToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiTokenMutation) ResetField(name string) error {
	switch name {
	case apitoken.FieldToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown ApiToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, apitoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apitoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, apitoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case apitoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiTokenMutation) ClearEdge(name string) error {
	switch name {
	case apitoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ApiToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiTokenMutation) ResetEdge(name string) error {
	switch name {
	case apitoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ApiToken edge %s", name)
}

// CardMutation represents an operation that mutates the Card nodes in the graph.
type CardMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	progress             *uint8
	addprogress          *int8
	total_errors         *int32
	addtotal_errors      *int32
	unlocked_at          *time.Time
	started_at           *time.Time
	passed_at            *time.Time
	available_at         *time.Time
	burned_at            *time.Time
	clearedFields        map[string]struct{}
	deck_progress        *int
	cleareddeck_progress bool
	subject              *uuid.UUID
	clearedsubject       bool
	reviews              map[uuid.UUID]struct{}
	removedreviews       map[uuid.UUID]struct{}
	clearedreviews       bool
	done                 bool
	oldValue             func(context.Context) (*Card, error)
	predicates           []predicate.Card
}

var _ ent.Mutation = (*CardMutation)(nil)

// cardOption allows management of the mutation configuration using functional options.
type cardOption func(*CardMutation)

// newCardMutation creates new mutation for the Card entity.
func newCardMutation(c config, op Op, opts ...cardOption) *CardMutation {
	m := &CardMutation{
		config:        c,
		op:            op,
		typ:           TypeCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCardID sets the ID field of the mutation.
func withCardID(id uuid.UUID) cardOption {
	return func(m *CardMutation) {
		var (
			err   error
			once  sync.Once
			value *Card
		)
		m.oldValue = func(ctx context.Context) (*Card, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Card.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCard sets the old Card of the mutation.
func withCard(node *Card) cardOption {
	return func(m *CardMutation) {
		m.oldValue = func(context.Context) (*Card, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Card entities.
func (m *CardMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CardMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CardMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Card.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProgress sets the "progress" field.
func (m *CardMutation) SetProgress(u uint8) {
	m.progress = &u
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *CardMutation) Progress() (r uint8, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldProgress(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds u to the "progress" field.
func (m *CardMutation) AddProgress(u int8) {
	if m.addprogress != nil {
		*m.addprogress += u
	} else {
		m.addprogress = &u
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *CardMutation) AddedProgress() (r int8, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *CardMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetTotalErrors sets the "total_errors" field.
func (m *CardMutation) SetTotalErrors(i int32) {
	m.total_errors = &i
	m.addtotal_errors = nil
}

// TotalErrors returns the value of the "total_errors" field in the mutation.
func (m *CardMutation) TotalErrors() (r int32, exists bool) {
	v := m.total_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalErrors returns the old "total_errors" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldTotalErrors(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalErrors: %w", err)
	}
	return oldValue.TotalErrors, nil
}

// AddTotalErrors adds i to the "total_errors" field.
func (m *CardMutation) AddTotalErrors(i int32) {
	if m.addtotal_errors != nil {
		*m.addtotal_errors += i
	} else {
		m.addtotal_errors = &i
	}
}

// AddedTotalErrors returns the value that was added to the "total_errors" field in this mutation.
func (m *CardMutation) AddedTotalErrors() (r int32, exists bool) {
	v := m.addtotal_errors
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalErrors resets all changes to the "total_errors" field.
func (m *CardMutation) ResetTotalErrors() {
	m.total_errors = nil
	m.addtotal_errors = nil
}

// SetUnlockedAt sets the "unlocked_at" field.
func (m *CardMutation) SetUnlockedAt(t time.Time) {
	m.unlocked_at = &t
}

// UnlockedAt returns the value of the "unlocked_at" field in the mutation.
func (m *CardMutation) UnlockedAt() (r time.Time, exists bool) {
	v := m.unlocked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUnlockedAt returns the old "unlocked_at" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldUnlockedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnlockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnlockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnlockedAt: %w", err)
	}
	return oldValue.UnlockedAt, nil
}

// ClearUnlockedAt clears the value of the "unlocked_at" field.
func (m *CardMutation) ClearUnlockedAt() {
	m.unlocked_at = nil
	m.clearedFields[card.FieldUnlockedAt] = struct{}{}
}

// UnlockedAtCleared returns if the "unlocked_at" field was cleared in this mutation.
func (m *CardMutation) UnlockedAtCleared() bool {
	_, ok := m.clearedFields[card.FieldUnlockedAt]
	return ok
}

// ResetUnlockedAt resets all changes to the "unlocked_at" field.
func (m *CardMutation) ResetUnlockedAt() {
	m.unlocked_at = nil
	delete(m.clearedFields, card.FieldUnlockedAt)
}

// SetStartedAt sets the "started_at" field.
func (m *CardMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *CardMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *CardMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[card.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *CardMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[card.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *CardMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, card.FieldStartedAt)
}

// SetPassedAt sets the "passed_at" field.
func (m *CardMutation) SetPassedAt(t time.Time) {
	m.passed_at = &t
}

// PassedAt returns the value of the "passed_at" field in the mutation.
func (m *CardMutation) PassedAt() (r time.Time, exists bool) {
	v := m.passed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPassedAt returns the old "passed_at" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldPassedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassedAt: %w", err)
	}
	return oldValue.PassedAt, nil
}

// ClearPassedAt clears the value of the "passed_at" field.
func (m *CardMutation) ClearPassedAt() {
	m.passed_at = nil
	m.clearedFields[card.FieldPassedAt] = struct{}{}
}

// PassedAtCleared returns if the "passed_at" field was cleared in this mutation.
func (m *CardMutation) PassedAtCleared() bool {
	_, ok := m.clearedFields[card.FieldPassedAt]
	return ok
}

// ResetPassedAt resets all changes to the "passed_at" field.
func (m *CardMutation) ResetPassedAt() {
	m.passed_at = nil
	delete(m.clearedFields, card.FieldPassedAt)
}

// SetAvailableAt sets the "available_at" field.
func (m *CardMutation) SetAvailableAt(t time.Time) {
	m.available_at = &t
}

// AvailableAt returns the value of the "available_at" field in the mutation.
func (m *CardMutation) AvailableAt() (r time.Time, exists bool) {
	v := m.available_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableAt returns the old "available_at" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldAvailableAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableAt: %w", err)
	}
	return oldValue.AvailableAt, nil
}

// ClearAvailableAt clears the value of the "available_at" field.
func (m *CardMutation) ClearAvailableAt() {
	m.available_at = nil
	m.clearedFields[card.FieldAvailableAt] = struct{}{}
}

// AvailableAtCleared returns if the "available_at" field was cleared in this mutation.
func (m *CardMutation) AvailableAtCleared() bool {
	_, ok := m.clearedFields[card.FieldAvailableAt]
	return ok
}

// ResetAvailableAt resets all changes to the "available_at" field.
func (m *CardMutation) ResetAvailableAt() {
	m.available_at = nil
	delete(m.clearedFields, card.FieldAvailableAt)
}

// SetBurnedAt sets the "burned_at" field.
func (m *CardMutation) SetBurnedAt(t time.Time) {
	m.burned_at = &t
}

// BurnedAt returns the value of the "burned_at" field in the mutation.
func (m *CardMutation) BurnedAt() (r time.Time, exists bool) {
	v := m.burned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldBurnedAt returns the old "burned_at" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldBurnedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBurnedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBurnedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBurnedAt: %w", err)
	}
	return oldValue.BurnedAt, nil
}

// ClearBurnedAt clears the value of the "burned_at" field.
func (m *CardMutation) ClearBurnedAt() {
	m.burned_at = nil
	m.clearedFields[card.FieldBurnedAt] = struct{}{}
}

// BurnedAtCleared returns if the "burned_at" field was cleared in this mutation.
func (m *CardMutation) BurnedAtCleared() bool {
	_, ok := m.clearedFields[card.FieldBurnedAt]
	return ok
}

// ResetBurnedAt resets all changes to the "burned_at" field.
func (m *CardMutation) ResetBurnedAt() {
	m.burned_at = nil
	delete(m.clearedFields, card.FieldBurnedAt)
}

// SetDeckProgressID sets the "deck_progress" edge to the DeckProgress entity by id.
func (m *CardMutation) SetDeckProgressID(id int) {
	m.deck_progress = &id
}

// ClearDeckProgress clears the "deck_progress" edge to the DeckProgress entity.
func (m *CardMutation) ClearDeckProgress() {
	m.cleareddeck_progress = true
}

// DeckProgressCleared reports if the "deck_progress" edge to the DeckProgress entity was cleared.
func (m *CardMutation) DeckProgressCleared() bool {
	return m.cleareddeck_progress
}

// DeckProgressID returns the "deck_progress" edge ID in the mutation.
func (m *CardMutation) DeckProgressID() (id int, exists bool) {
	if m.deck_progress != nil {
		return *m.deck_progress, true
	}
	return
}

// DeckProgressIDs returns the "deck_progress" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeckProgressID instead. It exists only for internal usage by the builders.
func (m *CardMutation) DeckProgressIDs() (ids []int) {
	if id := m.deck_progress; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeckProgress resets all changes to the "deck_progress" edge.
func (m *CardMutation) ResetDeckProgress() {
	m.deck_progress = nil
	m.cleareddeck_progress = false
}

// SetSubjectID sets the "subject" edge to the Subject entity by id.
func (m *CardMutation) SetSubjectID(id uuid.UUID) {
	m.subject = &id
}

// ClearSubject clears the "subject" edge to the Subject entity.
func (m *CardMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the Subject entity was cleared.
func (m *CardMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectID returns the "subject" edge ID in the mutation.
func (m *CardMutation) SubjectID() (id uuid.UUID, exists bool) {
	if m.subject != nil {
		return *m.subject, true
	}
	return
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *CardMutation) SubjectIDs() (ids []uuid.UUID) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *CardMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// AddReviewIDs adds the "reviews" edge to the Review entity by ids.
func (m *CardMutation) AddReviewIDs(ids ...uuid.UUID) {
	if m.reviews == nil {
		m.reviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the Review entity.
func (m *CardMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the Review entity was cleared.
func (m *CardMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the Review entity by IDs.
func (m *CardMutation) RemoveReviewIDs(ids ...uuid.UUID) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the Review entity.
func (m *CardMutation) RemovedReviewsIDs() (ids []uuid.UUID) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *CardMutation) ReviewsIDs() (ids []uuid.UUID) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *CardMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// Where appends a list predicates to the CardMutation builder.
func (m *CardMutation) Where(ps ...predicate.Card) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CardMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Card).
func (m *CardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CardMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, card.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, card.FieldUpdatedAt)
	}
	if m.progress != nil {
		fields = append(fields, card.FieldProgress)
	}
	if m.total_errors != nil {
		fields = append(fields, card.FieldTotalErrors)
	}
	if m.unlocked_at != nil {
		fields = append(fields, card.FieldUnlockedAt)
	}
	if m.started_at != nil {
		fields = append(fields, card.FieldStartedAt)
	}
	if m.passed_at != nil {
		fields = append(fields, card.FieldPassedAt)
	}
	if m.available_at != nil {
		fields = append(fields, card.FieldAvailableAt)
	}
	if m.burned_at != nil {
		fields = append(fields, card.FieldBurnedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case card.FieldCreatedAt:
		return m.CreatedAt()
	case card.FieldUpdatedAt:
		return m.UpdatedAt()
	case card.FieldProgress:
		return m.Progress()
	case card.FieldTotalErrors:
		return m.TotalErrors()
	case card.FieldUnlockedAt:
		return m.UnlockedAt()
	case card.FieldStartedAt:
		return m.StartedAt()
	case card.FieldPassedAt:
		return m.PassedAt()
	case card.FieldAvailableAt:
		return m.AvailableAt()
	case card.FieldBurnedAt:
		return m.BurnedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case card.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case card.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case card.FieldProgress:
		return m.OldProgress(ctx)
	case card.FieldTotalErrors:
		return m.OldTotalErrors(ctx)
	case card.FieldUnlockedAt:
		return m.OldUnlockedAt(ctx)
	case card.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case card.FieldPassedAt:
		return m.OldPassedAt(ctx)
	case card.FieldAvailableAt:
		return m.OldAvailableAt(ctx)
	case card.FieldBurnedAt:
		return m.OldBurnedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Card field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case card.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case card.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case card.FieldProgress:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case card.FieldTotalErrors:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalErrors(v)
		return nil
	case card.FieldUnlockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnlockedAt(v)
		return nil
	case card.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case card.FieldPassedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassedAt(v)
		return nil
	case card.FieldAvailableAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableAt(v)
		return nil
	case card.FieldBurnedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBurnedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CardMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, card.FieldProgress)
	}
	if m.addtotal_errors != nil {
		fields = append(fields, card.FieldTotalErrors)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case card.FieldProgress:
		return m.AddedProgress()
	case card.FieldTotalErrors:
		return m.AddedTotalErrors()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case card.FieldProgress:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	case card.FieldTotalErrors:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalErrors(v)
		return nil
	}
	return fmt.Errorf("unknown Card numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(card.FieldUnlockedAt) {
		fields = append(fields, card.FieldUnlockedAt)
	}
	if m.FieldCleared(card.FieldStartedAt) {
		fields = append(fields, card.FieldStartedAt)
	}
	if m.FieldCleared(card.FieldPassedAt) {
		fields = append(fields, card.FieldPassedAt)
	}
	if m.FieldCleared(card.FieldAvailableAt) {
		fields = append(fields, card.FieldAvailableAt)
	}
	if m.FieldCleared(card.FieldBurnedAt) {
		fields = append(fields, card.FieldBurnedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CardMutation) ClearField(name string) error {
	switch name {
	case card.FieldUnlockedAt:
		m.ClearUnlockedAt()
		return nil
	case card.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case card.FieldPassedAt:
		m.ClearPassedAt()
		return nil
	case card.FieldAvailableAt:
		m.ClearAvailableAt()
		return nil
	case card.FieldBurnedAt:
		m.ClearBurnedAt()
		return nil
	}
	return fmt.Errorf("unknown Card nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CardMutation) ResetField(name string) error {
	switch name {
	case card.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case card.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case card.FieldProgress:
		m.ResetProgress()
		return nil
	case card.FieldTotalErrors:
		m.ResetTotalErrors()
		return nil
	case card.FieldUnlockedAt:
		m.ResetUnlockedAt()
		return nil
	case card.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case card.FieldPassedAt:
		m.ResetPassedAt()
		return nil
	case card.FieldAvailableAt:
		m.ResetAvailableAt()
		return nil
	case card.FieldBurnedAt:
		m.ResetBurnedAt()
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CardMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.deck_progress != nil {
		edges = append(edges, card.EdgeDeckProgress)
	}
	if m.subject != nil {
		edges = append(edges, card.EdgeSubject)
	}
	if m.reviews != nil {
		edges = append(edges, card.EdgeReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeDeckProgress:
		if id := m.deck_progress; id != nil {
			return []ent.Value{*id}
		}
	case card.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	case card.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreviews != nil {
		edges = append(edges, card.EdgeReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddeck_progress {
		edges = append(edges, card.EdgeDeckProgress)
	}
	if m.clearedsubject {
		edges = append(edges, card.EdgeSubject)
	}
	if m.clearedreviews {
		edges = append(edges, card.EdgeReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CardMutation) EdgeCleared(name string) bool {
	switch name {
	case card.EdgeDeckProgress:
		return m.cleareddeck_progress
	case card.EdgeSubject:
		return m.clearedsubject
	case card.EdgeReviews:
		return m.clearedreviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CardMutation) ClearEdge(name string) error {
	switch name {
	case card.EdgeDeckProgress:
		m.ClearDeckProgress()
		return nil
	case card.EdgeSubject:
		m.ClearSubject()
		return nil
	}
	return fmt.Errorf("unknown Card unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CardMutation) ResetEdge(name string) error {
	switch name {
	case card.EdgeDeckProgress:
		m.ResetDeckProgress()
		return nil
	case card.EdgeSubject:
		m.ResetSubject()
		return nil
	case card.EdgeReviews:
		m.ResetReviews()
		return nil
	}
	return fmt.Errorf("unknown Card edge %s", name)
}

// DeckMutation represents an operation that mutates the Deck nodes in the graph.
type DeckMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	name                  *string
	description           *string
	clearedFields         map[string]struct{}
	subscribers           map[string]struct{}
	removedsubscribers    map[string]struct{}
	clearedsubscribers    bool
	owner                 *string
	clearedowner          bool
	subjects              map[uuid.UUID]struct{}
	removedsubjects       map[uuid.UUID]struct{}
	clearedsubjects       bool
	users_progress        map[int]struct{}
	removedusers_progress map[int]struct{}
	clearedusers_progress bool
	done                  bool
	oldValue              func(context.Context) (*Deck, error)
	predicates            []predicate.Deck
}

var _ ent.Mutation = (*DeckMutation)(nil)

// deckOption allows management of the mutation configuration using functional options.
type deckOption func(*DeckMutation)

// newDeckMutation creates new mutation for the Deck entity.
func newDeckMutation(c config, op Op, opts ...deckOption) *DeckMutation {
	m := &DeckMutation{
		config:        c,
		op:            op,
		typ:           TypeDeck,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeckID sets the ID field of the mutation.
func withDeckID(id uuid.UUID) deckOption {
	return func(m *DeckMutation) {
		var (
			err   error
			once  sync.Once
			value *Deck
		)
		m.oldValue = func(ctx context.Context) (*Deck, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deck.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeck sets the old Deck of the mutation.
func withDeck(node *Deck) deckOption {
	return func(m *DeckMutation) {
		m.oldValue = func(context.Context) (*Deck, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeckMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeckMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Deck entities.
func (m *DeckMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeckMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeckMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Deck.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeckMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeckMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeckMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeckMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeckMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeckMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *DeckMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeckMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeckMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DeckMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeckMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Deck entity.
// If the Deck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DeckMutation) ResetDescription() {
	m.description = nil
}

// AddSubscriberIDs adds the "subscribers" edge to the User entity by ids.
func (m *DeckMutation) AddSubscriberIDs(ids ...string) {
	if m.subscribers == nil {
		m.subscribers = make(map[string]struct{})
	}
	for i := range ids {
		m.subscribers[ids[i]] = struct{}{}
	}
}

// ClearSubscribers clears the "subscribers" edge to the User entity.
func (m *DeckMutation) ClearSubscribers() {
	m.clearedsubscribers = true
}

// SubscribersCleared reports if the "subscribers" edge to the User entity was cleared.
func (m *DeckMutation) SubscribersCleared() bool {
	return m.clearedsubscribers
}

// RemoveSubscriberIDs removes the "subscribers" edge to the User entity by IDs.
func (m *DeckMutation) RemoveSubscriberIDs(ids ...string) {
	if m.removedsubscribers == nil {
		m.removedsubscribers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscribers, ids[i])
		m.removedsubscribers[ids[i]] = struct{}{}
	}
}

// RemovedSubscribers returns the removed IDs of the "subscribers" edge to the User entity.
func (m *DeckMutation) RemovedSubscribersIDs() (ids []string) {
	for id := range m.removedsubscribers {
		ids = append(ids, id)
	}
	return
}

// SubscribersIDs returns the "subscribers" edge IDs in the mutation.
func (m *DeckMutation) SubscribersIDs() (ids []string) {
	for id := range m.subscribers {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribers resets all changes to the "subscribers" edge.
func (m *DeckMutation) ResetSubscribers() {
	m.subscribers = nil
	m.clearedsubscribers = false
	m.removedsubscribers = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *DeckMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *DeckMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *DeckMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *DeckMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DeckMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DeckMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddSubjectIDs adds the "subjects" edge to the Subject entity by ids.
func (m *DeckMutation) AddSubjectIDs(ids ...uuid.UUID) {
	if m.subjects == nil {
		m.subjects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the Subject entity.
func (m *DeckMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the Subject entity was cleared.
func (m *DeckMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the Subject entity by IDs.
func (m *DeckMutation) RemoveSubjectIDs(ids ...uuid.UUID) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the Subject entity.
func (m *DeckMutation) RemovedSubjectsIDs() (ids []uuid.UUID) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *DeckMutation) SubjectsIDs() (ids []uuid.UUID) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *DeckMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// AddUsersProgresIDs adds the "users_progress" edge to the DeckProgress entity by ids.
func (m *DeckMutation) AddUsersProgresIDs(ids ...int) {
	if m.users_progress == nil {
		m.users_progress = make(map[int]struct{})
	}
	for i := range ids {
		m.users_progress[ids[i]] = struct{}{}
	}
}

// ClearUsersProgress clears the "users_progress" edge to the DeckProgress entity.
func (m *DeckMutation) ClearUsersProgress() {
	m.clearedusers_progress = true
}

// UsersProgressCleared reports if the "users_progress" edge to the DeckProgress entity was cleared.
func (m *DeckMutation) UsersProgressCleared() bool {
	return m.clearedusers_progress
}

// RemoveUsersProgresIDs removes the "users_progress" edge to the DeckProgress entity by IDs.
func (m *DeckMutation) RemoveUsersProgresIDs(ids ...int) {
	if m.removedusers_progress == nil {
		m.removedusers_progress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users_progress, ids[i])
		m.removedusers_progress[ids[i]] = struct{}{}
	}
}

// RemovedUsersProgress returns the removed IDs of the "users_progress" edge to the DeckProgress entity.
func (m *DeckMutation) RemovedUsersProgressIDs() (ids []int) {
	for id := range m.removedusers_progress {
		ids = append(ids, id)
	}
	return
}

// UsersProgressIDs returns the "users_progress" edge IDs in the mutation.
func (m *DeckMutation) UsersProgressIDs() (ids []int) {
	for id := range m.users_progress {
		ids = append(ids, id)
	}
	return
}

// ResetUsersProgress resets all changes to the "users_progress" edge.
func (m *DeckMutation) ResetUsersProgress() {
	m.users_progress = nil
	m.clearedusers_progress = false
	m.removedusers_progress = nil
}

// Where appends a list predicates to the DeckMutation builder.
func (m *DeckMutation) Where(ps ...predicate.Deck) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeckMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Deck).
func (m *DeckMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeckMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, deck.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deck.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, deck.FieldName)
	}
	if m.description != nil {
		fields = append(fields, deck.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeckMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deck.FieldCreatedAt:
		return m.CreatedAt()
	case deck.FieldUpdatedAt:
		return m.UpdatedAt()
	case deck.FieldName:
		return m.Name()
	case deck.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeckMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deck.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deck.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deck.FieldName:
		return m.OldName(ctx)
	case deck.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Deck field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deck.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deck.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deck.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deck.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Deck field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeckMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeckMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Deck numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeckMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeckMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeckMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Deck nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeckMutation) ResetField(name string) error {
	switch name {
	case deck.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deck.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deck.FieldName:
		m.ResetName()
		return nil
	case deck.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Deck field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeckMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.subscribers != nil {
		edges = append(edges, deck.EdgeSubscribers)
	}
	if m.owner != nil {
		edges = append(edges, deck.EdgeOwner)
	}
	if m.subjects != nil {
		edges = append(edges, deck.EdgeSubjects)
	}
	if m.users_progress != nil {
		edges = append(edges, deck.EdgeUsersProgress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeckMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deck.EdgeSubscribers:
		ids := make([]ent.Value, 0, len(m.subscribers))
		for id := range m.subscribers {
			ids = append(ids, id)
		}
		return ids
	case deck.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case deck.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	case deck.EdgeUsersProgress:
		ids := make([]ent.Value, 0, len(m.users_progress))
		for id := range m.users_progress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeckMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsubscribers != nil {
		edges = append(edges, deck.EdgeSubscribers)
	}
	if m.removedsubjects != nil {
		edges = append(edges, deck.EdgeSubjects)
	}
	if m.removedusers_progress != nil {
		edges = append(edges, deck.EdgeUsersProgress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeckMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deck.EdgeSubscribers:
		ids := make([]ent.Value, 0, len(m.removedsubscribers))
		for id := range m.removedsubscribers {
			ids = append(ids, id)
		}
		return ids
	case deck.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	case deck.EdgeUsersProgress:
		ids := make([]ent.Value, 0, len(m.removedusers_progress))
		for id := range m.removedusers_progress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeckMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsubscribers {
		edges = append(edges, deck.EdgeSubscribers)
	}
	if m.clearedowner {
		edges = append(edges, deck.EdgeOwner)
	}
	if m.clearedsubjects {
		edges = append(edges, deck.EdgeSubjects)
	}
	if m.clearedusers_progress {
		edges = append(edges, deck.EdgeUsersProgress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeckMutation) EdgeCleared(name string) bool {
	switch name {
	case deck.EdgeSubscribers:
		return m.clearedsubscribers
	case deck.EdgeOwner:
		return m.clearedowner
	case deck.EdgeSubjects:
		return m.clearedsubjects
	case deck.EdgeUsersProgress:
		return m.clearedusers_progress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeckMutation) ClearEdge(name string) error {
	switch name {
	case deck.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Deck unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeckMutation) ResetEdge(name string) error {
	switch name {
	case deck.EdgeSubscribers:
		m.ResetSubscribers()
		return nil
	case deck.EdgeOwner:
		m.ResetOwner()
		return nil
	case deck.EdgeSubjects:
		m.ResetSubjects()
		return nil
	case deck.EdgeUsersProgress:
		m.ResetUsersProgress()
		return nil
	}
	return fmt.Errorf("unknown Deck edge %s", name)
}

// DeckProgressMutation represents an operation that mutates the DeckProgress nodes in the graph.
type DeckProgressMutation struct {
	config
	op            Op
	typ           string
	id            *int
	level         *uint32
	addlevel      *int32
	clearedFields map[string]struct{}
	cards         map[uuid.UUID]struct{}
	removedcards  map[uuid.UUID]struct{}
	clearedcards  bool
	user          *string
	cleareduser   bool
	deck          *uuid.UUID
	cleareddeck   bool
	done          bool
	oldValue      func(context.Context) (*DeckProgress, error)
	predicates    []predicate.DeckProgress
}

var _ ent.Mutation = (*DeckProgressMutation)(nil)

// deckprogressOption allows management of the mutation configuration using functional options.
type deckprogressOption func(*DeckProgressMutation)

// newDeckProgressMutation creates new mutation for the DeckProgress entity.
func newDeckProgressMutation(c config, op Op, opts ...deckprogressOption) *DeckProgressMutation {
	m := &DeckProgressMutation{
		config:        c,
		op:            op,
		typ:           TypeDeckProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeckProgressID sets the ID field of the mutation.
func withDeckProgressID(id int) deckprogressOption {
	return func(m *DeckProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *DeckProgress
		)
		m.oldValue = func(ctx context.Context) (*DeckProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeckProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeckProgress sets the old DeckProgress of the mutation.
func withDeckProgress(node *DeckProgress) deckprogressOption {
	return func(m *DeckProgressMutation) {
		m.oldValue = func(context.Context) (*DeckProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeckProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeckProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeckProgressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeckProgressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeckProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLevel sets the "level" field.
func (m *DeckProgressMutation) SetLevel(u uint32) {
	m.level = &u
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *DeckProgressMutation) Level() (r uint32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the DeckProgress entity.
// If the DeckProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeckProgressMutation) OldLevel(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds u to the "level" field.
func (m *DeckProgressMutation) AddLevel(u int32) {
	if m.addlevel != nil {
		*m.addlevel += u
	} else {
		m.addlevel = &u
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *DeckProgressMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *DeckProgressMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *DeckProgressMutation) AddCardIDs(ids ...uuid.UUID) {
	if m.cards == nil {
		m.cards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *DeckProgressMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *DeckProgressMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *DeckProgressMutation) RemoveCardIDs(ids ...uuid.UUID) {
	if m.removedcards == nil {
		m.removedcards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *DeckProgressMutation) RemovedCardsIDs() (ids []uuid.UUID) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *DeckProgressMutation) CardsIDs() (ids []uuid.UUID) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *DeckProgressMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *DeckProgressMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeckProgressMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeckProgressMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *DeckProgressMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeckProgressMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeckProgressMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetDeckID sets the "deck" edge to the Deck entity by id.
func (m *DeckProgressMutation) SetDeckID(id uuid.UUID) {
	m.deck = &id
}

// ClearDeck clears the "deck" edge to the Deck entity.
func (m *DeckProgressMutation) ClearDeck() {
	m.cleareddeck = true
}

// DeckCleared reports if the "deck" edge to the Deck entity was cleared.
func (m *DeckProgressMutation) DeckCleared() bool {
	return m.cleareddeck
}

// DeckID returns the "deck" edge ID in the mutation.
func (m *DeckProgressMutation) DeckID() (id uuid.UUID, exists bool) {
	if m.deck != nil {
		return *m.deck, true
	}
	return
}

// DeckIDs returns the "deck" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeckID instead. It exists only for internal usage by the builders.
func (m *DeckProgressMutation) DeckIDs() (ids []uuid.UUID) {
	if id := m.deck; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeck resets all changes to the "deck" edge.
func (m *DeckProgressMutation) ResetDeck() {
	m.deck = nil
	m.cleareddeck = false
}

// Where appends a list predicates to the DeckProgressMutation builder.
func (m *DeckProgressMutation) Where(ps ...predicate.DeckProgress) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeckProgressMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeckProgress).
func (m *DeckProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeckProgressMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.level != nil {
		fields = append(fields, deckprogress.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeckProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deckprogress.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeckProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deckprogress.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown DeckProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deckprogress.FieldLevel:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown DeckProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeckProgressMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, deckprogress.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeckProgressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deckprogress.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeckProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deckprogress.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown DeckProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeckProgressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeckProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeckProgressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeckProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeckProgressMutation) ResetField(name string) error {
	switch name {
	case deckprogress.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown DeckProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeckProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cards != nil {
		edges = append(edges, deckprogress.EdgeCards)
	}
	if m.user != nil {
		edges = append(edges, deckprogress.EdgeUser)
	}
	if m.deck != nil {
		edges = append(edges, deckprogress.EdgeDeck)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeckProgressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deckprogress.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	case deckprogress.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case deckprogress.EdgeDeck:
		if id := m.deck; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeckProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcards != nil {
		edges = append(edges, deckprogress.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeckProgressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deckprogress.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeckProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcards {
		edges = append(edges, deckprogress.EdgeCards)
	}
	if m.cleareduser {
		edges = append(edges, deckprogress.EdgeUser)
	}
	if m.cleareddeck {
		edges = append(edges, deckprogress.EdgeDeck)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeckProgressMutation) EdgeCleared(name string) bool {
	switch name {
	case deckprogress.EdgeCards:
		return m.clearedcards
	case deckprogress.EdgeUser:
		return m.cleareduser
	case deckprogress.EdgeDeck:
		return m.cleareddeck
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeckProgressMutation) ClearEdge(name string) error {
	switch name {
	case deckprogress.EdgeUser:
		m.ClearUser()
		return nil
	case deckprogress.EdgeDeck:
		m.ClearDeck()
		return nil
	}
	return fmt.Errorf("unknown DeckProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeckProgressMutation) ResetEdge(name string) error {
	switch name {
	case deckprogress.EdgeCards:
		m.ResetCards()
		return nil
	case deckprogress.EdgeUser:
		m.ResetUser()
		return nil
	case deckprogress.EdgeDeck:
		m.ResetDeck()
		return nil
	}
	return fmt.Errorf("unknown DeckProgress edge %s", name)
}

// ReviewMutation represents an operation that mutates the Review nodes in the graph.
type ReviewMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	meaning_errors    *int
	addmeaning_errors *int
	reading_errors    *int
	addreading_errors *int
	start_progress    *uint8
	addstart_progress *int8
	end_progress      *uint8
	addend_progress   *int8
	clearedFields     map[string]struct{}
	card              *uuid.UUID
	clearedcard       bool
	done              bool
	oldValue          func(context.Context) (*Review, error)
	predicates        []predicate.Review
}

var _ ent.Mutation = (*ReviewMutation)(nil)

// reviewOption allows management of the mutation configuration using functional options.
type reviewOption func(*ReviewMutation)

// newReviewMutation creates new mutation for the Review entity.
func newReviewMutation(c config, op Op, opts ...reviewOption) *ReviewMutation {
	m := &ReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewID sets the ID field of the mutation.
func withReviewID(id uuid.UUID) reviewOption {
	return func(m *ReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Review
		)
		m.oldValue = func(ctx context.Context) (*Review, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Review.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReview sets the old Review of the mutation.
func withReview(node *Review) reviewOption {
	return func(m *ReviewMutation) {
		m.oldValue = func(context.Context) (*Review, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Review entities.
func (m *ReviewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Review.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMeaningErrors sets the "meaning_errors" field.
func (m *ReviewMutation) SetMeaningErrors(i int) {
	m.meaning_errors = &i
	m.addmeaning_errors = nil
}

// MeaningErrors returns the value of the "meaning_errors" field in the mutation.
func (m *ReviewMutation) MeaningErrors() (r int, exists bool) {
	v := m.meaning_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldMeaningErrors returns the old "meaning_errors" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldMeaningErrors(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeaningErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeaningErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeaningErrors: %w", err)
	}
	return oldValue.MeaningErrors, nil
}

// AddMeaningErrors adds i to the "meaning_errors" field.
func (m *ReviewMutation) AddMeaningErrors(i int) {
	if m.addmeaning_errors != nil {
		*m.addmeaning_errors += i
	} else {
		m.addmeaning_errors = &i
	}
}

// AddedMeaningErrors returns the value that was added to the "meaning_errors" field in this mutation.
func (m *ReviewMutation) AddedMeaningErrors() (r int, exists bool) {
	v := m.addmeaning_errors
	if v == nil {
		return
	}
	return *v, true
}

// ResetMeaningErrors resets all changes to the "meaning_errors" field.
func (m *ReviewMutation) ResetMeaningErrors() {
	m.meaning_errors = nil
	m.addmeaning_errors = nil
}

// SetReadingErrors sets the "reading_errors" field.
func (m *ReviewMutation) SetReadingErrors(i int) {
	m.reading_errors = &i
	m.addreading_errors = nil
}

// ReadingErrors returns the value of the "reading_errors" field in the mutation.
func (m *ReviewMutation) ReadingErrors() (r int, exists bool) {
	v := m.reading_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldReadingErrors returns the old "reading_errors" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldReadingErrors(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadingErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadingErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadingErrors: %w", err)
	}
	return oldValue.ReadingErrors, nil
}

// AddReadingErrors adds i to the "reading_errors" field.
func (m *ReviewMutation) AddReadingErrors(i int) {
	if m.addreading_errors != nil {
		*m.addreading_errors += i
	} else {
		m.addreading_errors = &i
	}
}

// AddedReadingErrors returns the value that was added to the "reading_errors" field in this mutation.
func (m *ReviewMutation) AddedReadingErrors() (r int, exists bool) {
	v := m.addreading_errors
	if v == nil {
		return
	}
	return *v, true
}

// ResetReadingErrors resets all changes to the "reading_errors" field.
func (m *ReviewMutation) ResetReadingErrors() {
	m.reading_errors = nil
	m.addreading_errors = nil
}

// SetStartProgress sets the "start_progress" field.
func (m *ReviewMutation) SetStartProgress(u uint8) {
	m.start_progress = &u
	m.addstart_progress = nil
}

// StartProgress returns the value of the "start_progress" field in the mutation.
func (m *ReviewMutation) StartProgress() (r uint8, exists bool) {
	v := m.start_progress
	if v == nil {
		return
	}
	return *v, true
}

// OldStartProgress returns the old "start_progress" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldStartProgress(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartProgress: %w", err)
	}
	return oldValue.StartProgress, nil
}

// AddStartProgress adds u to the "start_progress" field.
func (m *ReviewMutation) AddStartProgress(u int8) {
	if m.addstart_progress != nil {
		*m.addstart_progress += u
	} else {
		m.addstart_progress = &u
	}
}

// AddedStartProgress returns the value that was added to the "start_progress" field in this mutation.
func (m *ReviewMutation) AddedStartProgress() (r int8, exists bool) {
	v := m.addstart_progress
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartProgress resets all changes to the "start_progress" field.
func (m *ReviewMutation) ResetStartProgress() {
	m.start_progress = nil
	m.addstart_progress = nil
}

// SetEndProgress sets the "end_progress" field.
func (m *ReviewMutation) SetEndProgress(u uint8) {
	m.end_progress = &u
	m.addend_progress = nil
}

// EndProgress returns the value of the "end_progress" field in the mutation.
func (m *ReviewMutation) EndProgress() (r uint8, exists bool) {
	v := m.end_progress
	if v == nil {
		return
	}
	return *v, true
}

// OldEndProgress returns the old "end_progress" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldEndProgress(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndProgress: %w", err)
	}
	return oldValue.EndProgress, nil
}

// AddEndProgress adds u to the "end_progress" field.
func (m *ReviewMutation) AddEndProgress(u int8) {
	if m.addend_progress != nil {
		*m.addend_progress += u
	} else {
		m.addend_progress = &u
	}
}

// AddedEndProgress returns the value that was added to the "end_progress" field in this mutation.
func (m *ReviewMutation) AddedEndProgress() (r int8, exists bool) {
	v := m.addend_progress
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndProgress resets all changes to the "end_progress" field.
func (m *ReviewMutation) ResetEndProgress() {
	m.end_progress = nil
	m.addend_progress = nil
}

// SetCardID sets the "card" edge to the Card entity by id.
func (m *ReviewMutation) SetCardID(id uuid.UUID) {
	m.card = &id
}

// ClearCard clears the "card" edge to the Card entity.
func (m *ReviewMutation) ClearCard() {
	m.clearedcard = true
}

// CardCleared reports if the "card" edge to the Card entity was cleared.
func (m *ReviewMutation) CardCleared() bool {
	return m.clearedcard
}

// CardID returns the "card" edge ID in the mutation.
func (m *ReviewMutation) CardID() (id uuid.UUID, exists bool) {
	if m.card != nil {
		return *m.card, true
	}
	return
}

// CardIDs returns the "card" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CardID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) CardIDs() (ids []uuid.UUID) {
	if id := m.card; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCard resets all changes to the "card" edge.
func (m *ReviewMutation) ResetCard() {
	m.card = nil
	m.clearedcard = false
}

// Where appends a list predicates to the ReviewMutation builder.
func (m *ReviewMutation) Where(ps ...predicate.Review) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReviewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Review).
func (m *ReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, review.FieldCreatedAt)
	}
	if m.meaning_errors != nil {
		fields = append(fields, review.FieldMeaningErrors)
	}
	if m.reading_errors != nil {
		fields = append(fields, review.FieldReadingErrors)
	}
	if m.start_progress != nil {
		fields = append(fields, review.FieldStartProgress)
	}
	if m.end_progress != nil {
		fields = append(fields, review.FieldEndProgress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case review.FieldCreatedAt:
		return m.CreatedAt()
	case review.FieldMeaningErrors:
		return m.MeaningErrors()
	case review.FieldReadingErrors:
		return m.ReadingErrors()
	case review.FieldStartProgress:
		return m.StartProgress()
	case review.FieldEndProgress:
		return m.EndProgress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case review.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case review.FieldMeaningErrors:
		return m.OldMeaningErrors(ctx)
	case review.FieldReadingErrors:
		return m.OldReadingErrors(ctx)
	case review.FieldStartProgress:
		return m.OldStartProgress(ctx)
	case review.FieldEndProgress:
		return m.OldEndProgress(ctx)
	}
	return nil, fmt.Errorf("unknown Review field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case review.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case review.FieldMeaningErrors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeaningErrors(v)
		return nil
	case review.FieldReadingErrors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadingErrors(v)
		return nil
	case review.FieldStartProgress:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartProgress(v)
		return nil
	case review.FieldEndProgress:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndProgress(v)
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewMutation) AddedFields() []string {
	var fields []string
	if m.addmeaning_errors != nil {
		fields = append(fields, review.FieldMeaningErrors)
	}
	if m.addreading_errors != nil {
		fields = append(fields, review.FieldReadingErrors)
	}
	if m.addstart_progress != nil {
		fields = append(fields, review.FieldStartProgress)
	}
	if m.addend_progress != nil {
		fields = append(fields, review.FieldEndProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case review.FieldMeaningErrors:
		return m.AddedMeaningErrors()
	case review.FieldReadingErrors:
		return m.AddedReadingErrors()
	case review.FieldStartProgress:
		return m.AddedStartProgress()
	case review.FieldEndProgress:
		return m.AddedEndProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case review.FieldMeaningErrors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMeaningErrors(v)
		return nil
	case review.FieldReadingErrors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadingErrors(v)
		return nil
	case review.FieldStartProgress:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartProgress(v)
		return nil
	case review.FieldEndProgress:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndProgress(v)
		return nil
	}
	return fmt.Errorf("unknown Review numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Review nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewMutation) ResetField(name string) error {
	switch name {
	case review.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case review.FieldMeaningErrors:
		m.ResetMeaningErrors()
		return nil
	case review.FieldReadingErrors:
		m.ResetReadingErrors()
		return nil
	case review.FieldStartProgress:
		m.ResetStartProgress()
		return nil
	case review.FieldEndProgress:
		m.ResetEndProgress()
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.card != nil {
		edges = append(edges, review.EdgeCard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeCard:
		if id := m.card; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcard {
		edges = append(edges, review.EdgeCard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case review.EdgeCard:
		return m.clearedcard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewMutation) ClearEdge(name string) error {
	switch name {
	case review.EdgeCard:
		m.ClearCard()
		return nil
	}
	return fmt.Errorf("unknown Review unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewMutation) ResetEdge(name string) error {
	switch name {
	case review.EdgeCard:
		m.ResetCard()
		return nil
	}
	return fmt.Errorf("unknown Review edge %s", name)
}

// SubjectMutation represents an operation that mutates the Subject nodes in the graph.
type SubjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	kind                *string
	level               *int32
	addlevel            *int32
	name                *string
	value               *string
	value_image         **cards.RemoteContent
	slug                *string
	priority            *uint8
	addpriority         *int8
	resources           **map[string][]cards.RemoteContent
	study_data          *[]cards.StudyData
	appendstudy_data    []cards.StudyData
	clearedFields       map[string]struct{}
	cards               map[uuid.UUID]struct{}
	removedcards        map[uuid.UUID]struct{}
	clearedcards        bool
	similar             map[uuid.UUID]struct{}
	removedsimilar      map[uuid.UUID]struct{}
	clearedsimilar      bool
	dependencies        map[uuid.UUID]struct{}
	removeddependencies map[uuid.UUID]struct{}
	cleareddependencies bool
	dependents          map[uuid.UUID]struct{}
	removeddependents   map[uuid.UUID]struct{}
	cleareddependents   bool
	deck                *uuid.UUID
	cleareddeck         bool
	owner               *string
	clearedowner        bool
	done                bool
	oldValue            func(context.Context) (*Subject, error)
	predicates          []predicate.Subject
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows management of the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for the Subject entity.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the ID field of the mutation.
func withSubjectID(id uuid.UUID) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subject entities.
func (m *SubjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKind sets the "kind" field.
func (m *SubjectMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *SubjectMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *SubjectMutation) ResetKind() {
	m.kind = nil
}

// SetLevel sets the "level" field.
func (m *SubjectMutation) SetLevel(i int32) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *SubjectMutation) Level() (r int32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *SubjectMutation) AddLevel(i int32) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *SubjectMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *SubjectMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetName sets the "name" field.
func (m *SubjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubjectMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *SubjectMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SubjectMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldValue(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *SubjectMutation) ClearValue() {
	m.value = nil
	m.clearedFields[subject.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *SubjectMutation) ValueCleared() bool {
	_, ok := m.clearedFields[subject.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *SubjectMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, subject.FieldValue)
}

// SetValueImage sets the "value_image" field.
func (m *SubjectMutation) SetValueImage(cc *cards.RemoteContent) {
	m.value_image = &cc
}

// ValueImage returns the value of the "value_image" field in the mutation.
func (m *SubjectMutation) ValueImage() (r *cards.RemoteContent, exists bool) {
	v := m.value_image
	if v == nil {
		return
	}
	return *v, true
}

// OldValueImage returns the old "value_image" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldValueImage(ctx context.Context) (v *cards.RemoteContent, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueImage: %w", err)
	}
	return oldValue.ValueImage, nil
}

// ClearValueImage clears the value of the "value_image" field.
func (m *SubjectMutation) ClearValueImage() {
	m.value_image = nil
	m.clearedFields[subject.FieldValueImage] = struct{}{}
}

// ValueImageCleared returns if the "value_image" field was cleared in this mutation.
func (m *SubjectMutation) ValueImageCleared() bool {
	_, ok := m.clearedFields[subject.FieldValueImage]
	return ok
}

// ResetValueImage resets all changes to the "value_image" field.
func (m *SubjectMutation) ResetValueImage() {
	m.value_image = nil
	delete(m.clearedFields, subject.FieldValueImage)
}

// SetSlug sets the "slug" field.
func (m *SubjectMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *SubjectMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *SubjectMutation) ResetSlug() {
	m.slug = nil
}

// SetPriority sets the "priority" field.
func (m *SubjectMutation) SetPriority(u uint8) {
	m.priority = &u
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *SubjectMutation) Priority() (r uint8, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldPriority(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds u to the "priority" field.
func (m *SubjectMutation) AddPriority(u int8) {
	if m.addpriority != nil {
		*m.addpriority += u
	} else {
		m.addpriority = &u
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *SubjectMutation) AddedPriority() (r int8, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *SubjectMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetResources sets the "resources" field.
func (m *SubjectMutation) SetResources(mc *map[string][]cards.RemoteContent) {
	m.resources = &mc
}

// Resources returns the value of the "resources" field in the mutation.
func (m *SubjectMutation) Resources() (r *map[string][]cards.RemoteContent, exists bool) {
	v := m.resources
	if v == nil {
		return
	}
	return *v, true
}

// OldResources returns the old "resources" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldResources(ctx context.Context) (v *map[string][]cards.RemoteContent, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResources is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResources requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResources: %w", err)
	}
	return oldValue.Resources, nil
}

// ClearResources clears the value of the "resources" field.
func (m *SubjectMutation) ClearResources() {
	m.resources = nil
	m.clearedFields[subject.FieldResources] = struct{}{}
}

// ResourcesCleared returns if the "resources" field was cleared in this mutation.
func (m *SubjectMutation) ResourcesCleared() bool {
	_, ok := m.clearedFields[subject.FieldResources]
	return ok
}

// ResetResources resets all changes to the "resources" field.
func (m *SubjectMutation) ResetResources() {
	m.resources = nil
	delete(m.clearedFields, subject.FieldResources)
}

// SetStudyData sets the "study_data" field.
func (m *SubjectMutation) SetStudyData(cd []cards.StudyData) {
	m.study_data = &cd
	m.appendstudy_data = nil
}

// StudyData returns the value of the "study_data" field in the mutation.
func (m *SubjectMutation) StudyData() (r []cards.StudyData, exists bool) {
	v := m.study_data
	if v == nil {
		return
	}
	return *v, true
}

// OldStudyData returns the old "study_data" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldStudyData(ctx context.Context) (v []cards.StudyData, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStudyData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStudyData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudyData: %w", err)
	}
	return oldValue.StudyData, nil
}

// AppendStudyData adds cd to the "study_data" field.
func (m *SubjectMutation) AppendStudyData(cd []cards.StudyData) {
	m.appendstudy_data = append(m.appendstudy_data, cd...)
}

// AppendedStudyData returns the list of values that were appended to the "study_data" field in this mutation.
func (m *SubjectMutation) AppendedStudyData() ([]cards.StudyData, bool) {
	if len(m.appendstudy_data) == 0 {
		return nil, false
	}
	return m.appendstudy_data, true
}

// ResetStudyData resets all changes to the "study_data" field.
func (m *SubjectMutation) ResetStudyData() {
	m.study_data = nil
	m.appendstudy_data = nil
}

// AddCardIDs adds the "cards" edge to the Card entity by ids.
func (m *SubjectMutation) AddCardIDs(ids ...uuid.UUID) {
	if m.cards == nil {
		m.cards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the Card entity.
func (m *SubjectMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the Card entity was cleared.
func (m *SubjectMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the Card entity by IDs.
func (m *SubjectMutation) RemoveCardIDs(ids ...uuid.UUID) {
	if m.removedcards == nil {
		m.removedcards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the Card entity.
func (m *SubjectMutation) RemovedCardsIDs() (ids []uuid.UUID) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *SubjectMutation) CardsIDs() (ids []uuid.UUID) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *SubjectMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// AddSimilarIDs adds the "similar" edge to the Subject entity by ids.
func (m *SubjectMutation) AddSimilarIDs(ids ...uuid.UUID) {
	if m.similar == nil {
		m.similar = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.similar[ids[i]] = struct{}{}
	}
}

// ClearSimilar clears the "similar" edge to the Subject entity.
func (m *SubjectMutation) ClearSimilar() {
	m.clearedsimilar = true
}

// SimilarCleared reports if the "similar" edge to the Subject entity was cleared.
func (m *SubjectMutation) SimilarCleared() bool {
	return m.clearedsimilar
}

// RemoveSimilarIDs removes the "similar" edge to the Subject entity by IDs.
func (m *SubjectMutation) RemoveSimilarIDs(ids ...uuid.UUID) {
	if m.removedsimilar == nil {
		m.removedsimilar = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.similar, ids[i])
		m.removedsimilar[ids[i]] = struct{}{}
	}
}

// RemovedSimilar returns the removed IDs of the "similar" edge to the Subject entity.
func (m *SubjectMutation) RemovedSimilarIDs() (ids []uuid.UUID) {
	for id := range m.removedsimilar {
		ids = append(ids, id)
	}
	return
}

// SimilarIDs returns the "similar" edge IDs in the mutation.
func (m *SubjectMutation) SimilarIDs() (ids []uuid.UUID) {
	for id := range m.similar {
		ids = append(ids, id)
	}
	return
}

// ResetSimilar resets all changes to the "similar" edge.
func (m *SubjectMutation) ResetSimilar() {
	m.similar = nil
	m.clearedsimilar = false
	m.removedsimilar = nil
}

// AddDependencyIDs adds the "dependencies" edge to the Subject entity by ids.
func (m *SubjectMutation) AddDependencyIDs(ids ...uuid.UUID) {
	if m.dependencies == nil {
		m.dependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the Subject entity.
func (m *SubjectMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the Subject entity was cleared.
func (m *SubjectMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the Subject entity by IDs.
func (m *SubjectMutation) RemoveDependencyIDs(ids ...uuid.UUID) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the Subject entity.
func (m *SubjectMutation) RemovedDependenciesIDs() (ids []uuid.UUID) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *SubjectMutation) DependenciesIDs() (ids []uuid.UUID) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *SubjectMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// AddDependentIDs adds the "dependents" edge to the Subject entity by ids.
func (m *SubjectMutation) AddDependentIDs(ids ...uuid.UUID) {
	if m.dependents == nil {
		m.dependents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.dependents[ids[i]] = struct{}{}
	}
}

// ClearDependents clears the "dependents" edge to the Subject entity.
func (m *SubjectMutation) ClearDependents() {
	m.cleareddependents = true
}

// DependentsCleared reports if the "dependents" edge to the Subject entity was cleared.
func (m *SubjectMutation) DependentsCleared() bool {
	return m.cleareddependents
}

// RemoveDependentIDs removes the "dependents" edge to the Subject entity by IDs.
func (m *SubjectMutation) RemoveDependentIDs(ids ...uuid.UUID) {
	if m.removeddependents == nil {
		m.removeddependents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.dependents, ids[i])
		m.removeddependents[ids[i]] = struct{}{}
	}
}

// RemovedDependents returns the removed IDs of the "dependents" edge to the Subject entity.
func (m *SubjectMutation) RemovedDependentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddependents {
		ids = append(ids, id)
	}
	return
}

// DependentsIDs returns the "dependents" edge IDs in the mutation.
func (m *SubjectMutation) DependentsIDs() (ids []uuid.UUID) {
	for id := range m.dependents {
		ids = append(ids, id)
	}
	return
}

// ResetDependents resets all changes to the "dependents" edge.
func (m *SubjectMutation) ResetDependents() {
	m.dependents = nil
	m.cleareddependents = false
	m.removeddependents = nil
}

// SetDeckID sets the "deck" edge to the Deck entity by id.
func (m *SubjectMutation) SetDeckID(id uuid.UUID) {
	m.deck = &id
}

// ClearDeck clears the "deck" edge to the Deck entity.
func (m *SubjectMutation) ClearDeck() {
	m.cleareddeck = true
}

// DeckCleared reports if the "deck" edge to the Deck entity was cleared.
func (m *SubjectMutation) DeckCleared() bool {
	return m.cleareddeck
}

// DeckID returns the "deck" edge ID in the mutation.
func (m *SubjectMutation) DeckID() (id uuid.UUID, exists bool) {
	if m.deck != nil {
		return *m.deck, true
	}
	return
}

// DeckIDs returns the "deck" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeckID instead. It exists only for internal usage by the builders.
func (m *SubjectMutation) DeckIDs() (ids []uuid.UUID) {
	if id := m.deck; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeck resets all changes to the "deck" edge.
func (m *SubjectMutation) ResetDeck() {
	m.deck = nil
	m.cleareddeck = false
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *SubjectMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *SubjectMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *SubjectMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *SubjectMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SubjectMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SubjectMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the SubjectMutation builder.
func (m *SubjectMutation) Where(ps ...predicate.Subject) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, subject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subject.FieldUpdatedAt)
	}
	if m.kind != nil {
		fields = append(fields, subject.FieldKind)
	}
	if m.level != nil {
		fields = append(fields, subject.FieldLevel)
	}
	if m.name != nil {
		fields = append(fields, subject.FieldName)
	}
	if m.value != nil {
		fields = append(fields, subject.FieldValue)
	}
	if m.value_image != nil {
		fields = append(fields, subject.FieldValueImage)
	}
	if m.slug != nil {
		fields = append(fields, subject.FieldSlug)
	}
	if m.priority != nil {
		fields = append(fields, subject.FieldPriority)
	}
	if m.resources != nil {
		fields = append(fields, subject.FieldResources)
	}
	if m.study_data != nil {
		fields = append(fields, subject.FieldStudyData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldCreatedAt:
		return m.CreatedAt()
	case subject.FieldUpdatedAt:
		return m.UpdatedAt()
	case subject.FieldKind:
		return m.Kind()
	case subject.FieldLevel:
		return m.Level()
	case subject.FieldName:
		return m.Name()
	case subject.FieldValue:
		return m.Value()
	case subject.FieldValueImage:
		return m.ValueImage()
	case subject.FieldSlug:
		return m.Slug()
	case subject.FieldPriority:
		return m.Priority()
	case subject.FieldResources:
		return m.Resources()
	case subject.FieldStudyData:
		return m.StudyData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subject.FieldKind:
		return m.OldKind(ctx)
	case subject.FieldLevel:
		return m.OldLevel(ctx)
	case subject.FieldName:
		return m.OldName(ctx)
	case subject.FieldValue:
		return m.OldValue(ctx)
	case subject.FieldValueImage:
		return m.OldValueImage(ctx)
	case subject.FieldSlug:
		return m.OldSlug(ctx)
	case subject.FieldPriority:
		return m.OldPriority(ctx)
	case subject.FieldResources:
		return m.OldResources(ctx)
	case subject.FieldStudyData:
		return m.OldStudyData(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subject.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case subject.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case subject.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subject.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case subject.FieldValueImage:
		v, ok := value.(*cards.RemoteContent)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueImage(v)
		return nil
	case subject.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case subject.FieldPriority:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case subject.FieldResources:
		v, ok := value.(*map[string][]cards.RemoteContent)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResources(v)
		return nil
	case subject.FieldStudyData:
		v, ok := value.([]cards.StudyData)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudyData(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, subject.FieldLevel)
	}
	if m.addpriority != nil {
		fields = append(fields, subject.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldLevel:
		return m.AddedLevel()
	case subject.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subject.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case subject.FieldPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subject.FieldValue) {
		fields = append(fields, subject.FieldValue)
	}
	if m.FieldCleared(subject.FieldValueImage) {
		fields = append(fields, subject.FieldValueImage)
	}
	if m.FieldCleared(subject.FieldResources) {
		fields = append(fields, subject.FieldResources)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	switch name {
	case subject.FieldValue:
		m.ClearValue()
		return nil
	case subject.FieldValueImage:
		m.ClearValueImage()
		return nil
	case subject.FieldResources:
		m.ClearResources()
		return nil
	}
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subject.FieldKind:
		m.ResetKind()
		return nil
	case subject.FieldLevel:
		m.ResetLevel()
		return nil
	case subject.FieldName:
		m.ResetName()
		return nil
	case subject.FieldValue:
		m.ResetValue()
		return nil
	case subject.FieldValueImage:
		m.ResetValueImage()
		return nil
	case subject.FieldSlug:
		m.ResetSlug()
		return nil
	case subject.FieldPriority:
		m.ResetPriority()
		return nil
	case subject.FieldResources:
		m.ResetResources()
		return nil
	case subject.FieldStudyData:
		m.ResetStudyData()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cards != nil {
		edges = append(edges, subject.EdgeCards)
	}
	if m.similar != nil {
		edges = append(edges, subject.EdgeSimilar)
	}
	if m.dependencies != nil {
		edges = append(edges, subject.EdgeDependencies)
	}
	if m.dependents != nil {
		edges = append(edges, subject.EdgeDependents)
	}
	if m.deck != nil {
		edges = append(edges, subject.EdgeDeck)
	}
	if m.owner != nil {
		edges = append(edges, subject.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeSimilar:
		ids := make([]ent.Value, 0, len(m.similar))
		for id := range m.similar {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.dependents))
		for id := range m.dependents {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeDeck:
		if id := m.deck; id != nil {
			return []ent.Value{*id}
		}
	case subject.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcards != nil {
		edges = append(edges, subject.EdgeCards)
	}
	if m.removedsimilar != nil {
		edges = append(edges, subject.EdgeSimilar)
	}
	if m.removeddependencies != nil {
		edges = append(edges, subject.EdgeDependencies)
	}
	if m.removeddependents != nil {
		edges = append(edges, subject.EdgeDependents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeSimilar:
		ids := make([]ent.Value, 0, len(m.removedsimilar))
		for id := range m.removedsimilar {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.removeddependents))
		for id := range m.removeddependents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcards {
		edges = append(edges, subject.EdgeCards)
	}
	if m.clearedsimilar {
		edges = append(edges, subject.EdgeSimilar)
	}
	if m.cleareddependencies {
		edges = append(edges, subject.EdgeDependencies)
	}
	if m.cleareddependents {
		edges = append(edges, subject.EdgeDependents)
	}
	if m.cleareddeck {
		edges = append(edges, subject.EdgeDeck)
	}
	if m.clearedowner {
		edges = append(edges, subject.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	case subject.EdgeCards:
		return m.clearedcards
	case subject.EdgeSimilar:
		return m.clearedsimilar
	case subject.EdgeDependencies:
		return m.cleareddependencies
	case subject.EdgeDependents:
		return m.cleareddependents
	case subject.EdgeDeck:
		return m.cleareddeck
	case subject.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	case subject.EdgeDeck:
		m.ClearDeck()
		return nil
	case subject.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeCards:
		m.ResetCards()
		return nil
	case subject.EdgeSimilar:
		m.ResetSimilar()
		return nil
	case subject.EdgeDependencies:
		m.ResetDependencies()
		return nil
	case subject.EdgeDependents:
		m.ResetDependents()
		return nil
	case subject.EdgeDeck:
		m.ResetDeck()
		return nil
	case subject.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	username                *string
	pending_actions         *[]schema.PendingAction
	appendpending_actions   []schema.PendingAction
	email                   *string
	clearedFields           map[string]struct{}
	decks                   map[uuid.UUID]struct{}
	removeddecks            map[uuid.UUID]struct{}
	cleareddecks            bool
	subjects                map[uuid.UUID]struct{}
	removedsubjects         map[uuid.UUID]struct{}
	clearedsubjects         bool
	subscribed_decks        map[uuid.UUID]struct{}
	removedsubscribed_decks map[uuid.UUID]struct{}
	clearedsubscribed_decks bool
	api_tokens              map[uuid.UUID]struct{}
	removedapi_tokens       map[uuid.UUID]struct{}
	clearedapi_tokens       bool
	decks_progress          map[int]struct{}
	removeddecks_progress   map[int]struct{}
	cleareddecks_progress   bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPendingActions sets the "pending_actions" field.
func (m *UserMutation) SetPendingActions(sa []schema.PendingAction) {
	m.pending_actions = &sa
	m.appendpending_actions = nil
}

// PendingActions returns the value of the "pending_actions" field in the mutation.
func (m *UserMutation) PendingActions() (r []schema.PendingAction, exists bool) {
	v := m.pending_actions
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingActions returns the old "pending_actions" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPendingActions(ctx context.Context) (v []schema.PendingAction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingActions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingActions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingActions: %w", err)
	}
	return oldValue.PendingActions, nil
}

// AppendPendingActions adds sa to the "pending_actions" field.
func (m *UserMutation) AppendPendingActions(sa []schema.PendingAction) {
	m.appendpending_actions = append(m.appendpending_actions, sa...)
}

// AppendedPendingActions returns the list of values that were appended to the "pending_actions" field in this mutation.
func (m *UserMutation) AppendedPendingActions() ([]schema.PendingAction, bool) {
	if len(m.appendpending_actions) == 0 {
		return nil, false
	}
	return m.appendpending_actions, true
}

// ResetPendingActions resets all changes to the "pending_actions" field.
func (m *UserMutation) ResetPendingActions() {
	m.pending_actions = nil
	m.appendpending_actions = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddDeckIDs adds the "decks" edge to the Deck entity by ids.
func (m *UserMutation) AddDeckIDs(ids ...uuid.UUID) {
	if m.decks == nil {
		m.decks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.decks[ids[i]] = struct{}{}
	}
}

// ClearDecks clears the "decks" edge to the Deck entity.
func (m *UserMutation) ClearDecks() {
	m.cleareddecks = true
}

// DecksCleared reports if the "decks" edge to the Deck entity was cleared.
func (m *UserMutation) DecksCleared() bool {
	return m.cleareddecks
}

// RemoveDeckIDs removes the "decks" edge to the Deck entity by IDs.
func (m *UserMutation) RemoveDeckIDs(ids ...uuid.UUID) {
	if m.removeddecks == nil {
		m.removeddecks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.decks, ids[i])
		m.removeddecks[ids[i]] = struct{}{}
	}
}

// RemovedDecks returns the removed IDs of the "decks" edge to the Deck entity.
func (m *UserMutation) RemovedDecksIDs() (ids []uuid.UUID) {
	for id := range m.removeddecks {
		ids = append(ids, id)
	}
	return
}

// DecksIDs returns the "decks" edge IDs in the mutation.
func (m *UserMutation) DecksIDs() (ids []uuid.UUID) {
	for id := range m.decks {
		ids = append(ids, id)
	}
	return
}

// ResetDecks resets all changes to the "decks" edge.
func (m *UserMutation) ResetDecks() {
	m.decks = nil
	m.cleareddecks = false
	m.removeddecks = nil
}

// AddSubjectIDs adds the "subjects" edge to the Subject entity by ids.
func (m *UserMutation) AddSubjectIDs(ids ...uuid.UUID) {
	if m.subjects == nil {
		m.subjects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the Subject entity.
func (m *UserMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the Subject entity was cleared.
func (m *UserMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the Subject entity by IDs.
func (m *UserMutation) RemoveSubjectIDs(ids ...uuid.UUID) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the Subject entity.
func (m *UserMutation) RemovedSubjectsIDs() (ids []uuid.UUID) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *UserMutation) SubjectsIDs() (ids []uuid.UUID) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *UserMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// AddSubscribedDeckIDs adds the "subscribed_decks" edge to the Deck entity by ids.
func (m *UserMutation) AddSubscribedDeckIDs(ids ...uuid.UUID) {
	if m.subscribed_decks == nil {
		m.subscribed_decks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subscribed_decks[ids[i]] = struct{}{}
	}
}

// ClearSubscribedDecks clears the "subscribed_decks" edge to the Deck entity.
func (m *UserMutation) ClearSubscribedDecks() {
	m.clearedsubscribed_decks = true
}

// SubscribedDecksCleared reports if the "subscribed_decks" edge to the Deck entity was cleared.
func (m *UserMutation) SubscribedDecksCleared() bool {
	return m.clearedsubscribed_decks
}

// RemoveSubscribedDeckIDs removes the "subscribed_decks" edge to the Deck entity by IDs.
func (m *UserMutation) RemoveSubscribedDeckIDs(ids ...uuid.UUID) {
	if m.removedsubscribed_decks == nil {
		m.removedsubscribed_decks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subscribed_decks, ids[i])
		m.removedsubscribed_decks[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedDecks returns the removed IDs of the "subscribed_decks" edge to the Deck entity.
func (m *UserMutation) RemovedSubscribedDecksIDs() (ids []uuid.UUID) {
	for id := range m.removedsubscribed_decks {
		ids = append(ids, id)
	}
	return
}

// SubscribedDecksIDs returns the "subscribed_decks" edge IDs in the mutation.
func (m *UserMutation) SubscribedDecksIDs() (ids []uuid.UUID) {
	for id := range m.subscribed_decks {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedDecks resets all changes to the "subscribed_decks" edge.
func (m *UserMutation) ResetSubscribedDecks() {
	m.subscribed_decks = nil
	m.clearedsubscribed_decks = false
	m.removedsubscribed_decks = nil
}

// AddAPITokenIDs adds the "api_tokens" edge to the ApiToken entity by ids.
func (m *UserMutation) AddAPITokenIDs(ids ...uuid.UUID) {
	if m.api_tokens == nil {
		m.api_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.api_tokens[ids[i]] = struct{}{}
	}
}

// ClearAPITokens clears the "api_tokens" edge to the ApiToken entity.
func (m *UserMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the ApiToken entity was cleared.
func (m *UserMutation) APITokensCleared() bool {
	return m.clearedapi_tokens
}

// RemoveAPITokenIDs removes the "api_tokens" edge to the ApiToken entity by IDs.
func (m *UserMutation) RemoveAPITokenIDs(ids ...uuid.UUID) {
	if m.removedapi_tokens == nil {
		m.removedapi_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.api_tokens, ids[i])
		m.removedapi_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAPITokens returns the removed IDs of the "api_tokens" edge to the ApiToken entity.
func (m *UserMutation) RemovedAPITokensIDs() (ids []uuid.UUID) {
	for id := range m.removedapi_tokens {
		ids = append(ids, id)
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
func (m *UserMutation) APITokensIDs() (ids []uuid.UUID) {
	for id := range m.api_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *UserMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
	m.removedapi_tokens = nil
}

// AddDecksProgresIDs adds the "decks_progress" edge to the DeckProgress entity by ids.
func (m *UserMutation) AddDecksProgresIDs(ids ...int) {
	if m.decks_progress == nil {
		m.decks_progress = make(map[int]struct{})
	}
	for i := range ids {
		m.decks_progress[ids[i]] = struct{}{}
	}
}

// ClearDecksProgress clears the "decks_progress" edge to the DeckProgress entity.
func (m *UserMutation) ClearDecksProgress() {
	m.cleareddecks_progress = true
}

// DecksProgressCleared reports if the "decks_progress" edge to the DeckProgress entity was cleared.
func (m *UserMutation) DecksProgressCleared() bool {
	return m.cleareddecks_progress
}

// RemoveDecksProgresIDs removes the "decks_progress" edge to the DeckProgress entity by IDs.
func (m *UserMutation) RemoveDecksProgresIDs(ids ...int) {
	if m.removeddecks_progress == nil {
		m.removeddecks_progress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.decks_progress, ids[i])
		m.removeddecks_progress[ids[i]] = struct{}{}
	}
}

// RemovedDecksProgress returns the removed IDs of the "decks_progress" edge to the DeckProgress entity.
func (m *UserMutation) RemovedDecksProgressIDs() (ids []int) {
	for id := range m.removeddecks_progress {
		ids = append(ids, id)
	}
	return
}

// DecksProgressIDs returns the "decks_progress" edge IDs in the mutation.
func (m *UserMutation) DecksProgressIDs() (ids []int) {
	for id := range m.decks_progress {
		ids = append(ids, id)
	}
	return
}

// ResetDecksProgress resets all changes to the "decks_progress" edge.
func (m *UserMutation) ResetDecksProgress() {
	m.decks_progress = nil
	m.cleareddecks_progress = false
	m.removeddecks_progress = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.pending_actions != nil {
		fields = append(fields, user.FieldPendingActions)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPendingActions:
		return m.PendingActions()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPendingActions:
		return m.OldPendingActions(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPendingActions:
		v, ok := value.([]schema.PendingAction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingActions(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPendingActions:
		m.ResetPendingActions()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.decks != nil {
		edges = append(edges, user.EdgeDecks)
	}
	if m.subjects != nil {
		edges = append(edges, user.EdgeSubjects)
	}
	if m.subscribed_decks != nil {
		edges = append(edges, user.EdgeSubscribedDecks)
	}
	if m.api_tokens != nil {
		edges = append(edges, user.EdgeAPITokens)
	}
	if m.decks_progress != nil {
		edges = append(edges, user.EdgeDecksProgress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDecks:
		ids := make([]ent.Value, 0, len(m.decks))
		for id := range m.decks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedDecks:
		ids := make([]ent.Value, 0, len(m.subscribed_decks))
		for id := range m.subscribed_decks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.api_tokens))
		for id := range m.api_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDecksProgress:
		ids := make([]ent.Value, 0, len(m.decks_progress))
		for id := range m.decks_progress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeddecks != nil {
		edges = append(edges, user.EdgeDecks)
	}
	if m.removedsubjects != nil {
		edges = append(edges, user.EdgeSubjects)
	}
	if m.removedsubscribed_decks != nil {
		edges = append(edges, user.EdgeSubscribedDecks)
	}
	if m.removedapi_tokens != nil {
		edges = append(edges, user.EdgeAPITokens)
	}
	if m.removeddecks_progress != nil {
		edges = append(edges, user.EdgeDecksProgress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDecks:
		ids := make([]ent.Value, 0, len(m.removeddecks))
		for id := range m.removeddecks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedDecks:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_decks))
		for id := range m.removedsubscribed_decks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.removedapi_tokens))
		for id := range m.removedapi_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDecksProgress:
		ids := make([]ent.Value, 0, len(m.removeddecks_progress))
		for id := range m.removeddecks_progress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareddecks {
		edges = append(edges, user.EdgeDecks)
	}
	if m.clearedsubjects {
		edges = append(edges, user.EdgeSubjects)
	}
	if m.clearedsubscribed_decks {
		edges = append(edges, user.EdgeSubscribedDecks)
	}
	if m.clearedapi_tokens {
		edges = append(edges, user.EdgeAPITokens)
	}
	if m.cleareddecks_progress {
		edges = append(edges, user.EdgeDecksProgress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDecks:
		return m.cleareddecks
	case user.EdgeSubjects:
		return m.clearedsubjects
	case user.EdgeSubscribedDecks:
		return m.clearedsubscribed_decks
	case user.EdgeAPITokens:
		return m.clearedapi_tokens
	case user.EdgeDecksProgress:
		return m.cleareddecks_progress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDecks:
		m.ResetDecks()
		return nil
	case user.EdgeSubjects:
		m.ResetSubjects()
		return nil
	case user.EdgeSubscribedDecks:
		m.ResetSubscribedDecks()
		return nil
	case user.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	case user.EdgeDecksProgress:
		m.ResetDecksProgress()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
