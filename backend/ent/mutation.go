// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
	"sixels.io/manekani/ent/kanji"
	"sixels.io/manekani/ent/predicate"
	"sixels.io/manekani/ent/radical"
	"sixels.io/manekani/ent/schema"
	"sixels.io/manekani/ent/vocabulary"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeKanji      = "Kanji"
	TypeRadical    = "Radical"
	TypeVocabulary = "Vocabulary"
)

// KanjiMutation represents an operation that mutates the Kanji nodes in the graph.
type KanjiMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	symbol              *string
	name                *string
	alt_names           *pgtype.TextArray
	similar             *pgtype.TextArray
	level               *int32
	addlevel            *int32
	reading             *string
	onyomi              *pgtype.TextArray
	kunyomi             *pgtype.TextArray
	nanori              *pgtype.TextArray
	meaning_mnemonic    *string
	reading_mnemonic    *string
	clearedFields       map[string]struct{}
	vocabularies        map[uuid.UUID]struct{}
	removedvocabularies map[uuid.UUID]struct{}
	clearedvocabularies bool
	radicals            map[uuid.UUID]struct{}
	removedradicals     map[uuid.UUID]struct{}
	clearedradicals     bool
	done                bool
	oldValue            func(context.Context) (*Kanji, error)
	predicates          []predicate.Kanji
}

var _ ent.Mutation = (*KanjiMutation)(nil)

// kanjiOption allows management of the mutation configuration using functional options.
type kanjiOption func(*KanjiMutation)

// newKanjiMutation creates new mutation for the Kanji entity.
func newKanjiMutation(c config, op Op, opts ...kanjiOption) *KanjiMutation {
	m := &KanjiMutation{
		config:        c,
		op:            op,
		typ:           TypeKanji,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKanjiID sets the ID field of the mutation.
func withKanjiID(id uuid.UUID) kanjiOption {
	return func(m *KanjiMutation) {
		var (
			err   error
			once  sync.Once
			value *Kanji
		)
		m.oldValue = func(ctx context.Context) (*Kanji, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Kanji.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKanji sets the old Kanji of the mutation.
func withKanji(node *Kanji) kanjiOption {
	return func(m *KanjiMutation) {
		m.oldValue = func(context.Context) (*Kanji, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KanjiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KanjiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Kanji entities.
func (m *KanjiMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KanjiMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KanjiMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Kanji.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *KanjiMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KanjiMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KanjiMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KanjiMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KanjiMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KanjiMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSymbol sets the "symbol" field.
func (m *KanjiMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *KanjiMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *KanjiMutation) ResetSymbol() {
	m.symbol = nil
}

// SetName sets the "name" field.
func (m *KanjiMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *KanjiMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *KanjiMutation) ResetName() {
	m.name = nil
}

// SetAltNames sets the "alt_names" field.
func (m *KanjiMutation) SetAltNames(pa pgtype.TextArray) {
	m.alt_names = &pa
}

// AltNames returns the value of the "alt_names" field in the mutation.
func (m *KanjiMutation) AltNames() (r pgtype.TextArray, exists bool) {
	v := m.alt_names
	if v == nil {
		return
	}
	return *v, true
}

// OldAltNames returns the old "alt_names" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldAltNames(ctx context.Context) (v pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltNames: %w", err)
	}
	return oldValue.AltNames, nil
}

// ClearAltNames clears the value of the "alt_names" field.
func (m *KanjiMutation) ClearAltNames() {
	m.alt_names = nil
	m.clearedFields[kanji.FieldAltNames] = struct{}{}
}

// AltNamesCleared returns if the "alt_names" field was cleared in this mutation.
func (m *KanjiMutation) AltNamesCleared() bool {
	_, ok := m.clearedFields[kanji.FieldAltNames]
	return ok
}

// ResetAltNames resets all changes to the "alt_names" field.
func (m *KanjiMutation) ResetAltNames() {
	m.alt_names = nil
	delete(m.clearedFields, kanji.FieldAltNames)
}

// SetSimilar sets the "similar" field.
func (m *KanjiMutation) SetSimilar(pa pgtype.TextArray) {
	m.similar = &pa
}

// Similar returns the value of the "similar" field in the mutation.
func (m *KanjiMutation) Similar() (r pgtype.TextArray, exists bool) {
	v := m.similar
	if v == nil {
		return
	}
	return *v, true
}

// OldSimilar returns the old "similar" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldSimilar(ctx context.Context) (v pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimilar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimilar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimilar: %w", err)
	}
	return oldValue.Similar, nil
}

// ClearSimilar clears the value of the "similar" field.
func (m *KanjiMutation) ClearSimilar() {
	m.similar = nil
	m.clearedFields[kanji.FieldSimilar] = struct{}{}
}

// SimilarCleared returns if the "similar" field was cleared in this mutation.
func (m *KanjiMutation) SimilarCleared() bool {
	_, ok := m.clearedFields[kanji.FieldSimilar]
	return ok
}

// ResetSimilar resets all changes to the "similar" field.
func (m *KanjiMutation) ResetSimilar() {
	m.similar = nil
	delete(m.clearedFields, kanji.FieldSimilar)
}

// SetLevel sets the "level" field.
func (m *KanjiMutation) SetLevel(i int32) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *KanjiMutation) Level() (r int32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *KanjiMutation) AddLevel(i int32) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *KanjiMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *KanjiMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetReading sets the "reading" field.
func (m *KanjiMutation) SetReading(s string) {
	m.reading = &s
}

// Reading returns the value of the "reading" field in the mutation.
func (m *KanjiMutation) Reading() (r string, exists bool) {
	v := m.reading
	if v == nil {
		return
	}
	return *v, true
}

// OldReading returns the old "reading" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldReading(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReading is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReading requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReading: %w", err)
	}
	return oldValue.Reading, nil
}

// ResetReading resets all changes to the "reading" field.
func (m *KanjiMutation) ResetReading() {
	m.reading = nil
}

// SetOnyomi sets the "onyomi" field.
func (m *KanjiMutation) SetOnyomi(pa pgtype.TextArray) {
	m.onyomi = &pa
}

// Onyomi returns the value of the "onyomi" field in the mutation.
func (m *KanjiMutation) Onyomi() (r pgtype.TextArray, exists bool) {
	v := m.onyomi
	if v == nil {
		return
	}
	return *v, true
}

// OldOnyomi returns the old "onyomi" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldOnyomi(ctx context.Context) (v pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnyomi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnyomi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnyomi: %w", err)
	}
	return oldValue.Onyomi, nil
}

// ResetOnyomi resets all changes to the "onyomi" field.
func (m *KanjiMutation) ResetOnyomi() {
	m.onyomi = nil
}

// SetKunyomi sets the "kunyomi" field.
func (m *KanjiMutation) SetKunyomi(pa pgtype.TextArray) {
	m.kunyomi = &pa
}

// Kunyomi returns the value of the "kunyomi" field in the mutation.
func (m *KanjiMutation) Kunyomi() (r pgtype.TextArray, exists bool) {
	v := m.kunyomi
	if v == nil {
		return
	}
	return *v, true
}

// OldKunyomi returns the old "kunyomi" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldKunyomi(ctx context.Context) (v pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKunyomi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKunyomi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKunyomi: %w", err)
	}
	return oldValue.Kunyomi, nil
}

// ResetKunyomi resets all changes to the "kunyomi" field.
func (m *KanjiMutation) ResetKunyomi() {
	m.kunyomi = nil
}

// SetNanori sets the "nanori" field.
func (m *KanjiMutation) SetNanori(pa pgtype.TextArray) {
	m.nanori = &pa
}

// Nanori returns the value of the "nanori" field in the mutation.
func (m *KanjiMutation) Nanori() (r pgtype.TextArray, exists bool) {
	v := m.nanori
	if v == nil {
		return
	}
	return *v, true
}

// OldNanori returns the old "nanori" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldNanori(ctx context.Context) (v pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNanori is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNanori requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNanori: %w", err)
	}
	return oldValue.Nanori, nil
}

// ResetNanori resets all changes to the "nanori" field.
func (m *KanjiMutation) ResetNanori() {
	m.nanori = nil
}

// SetMeaningMnemonic sets the "meaning_mnemonic" field.
func (m *KanjiMutation) SetMeaningMnemonic(s string) {
	m.meaning_mnemonic = &s
}

// MeaningMnemonic returns the value of the "meaning_mnemonic" field in the mutation.
func (m *KanjiMutation) MeaningMnemonic() (r string, exists bool) {
	v := m.meaning_mnemonic
	if v == nil {
		return
	}
	return *v, true
}

// OldMeaningMnemonic returns the old "meaning_mnemonic" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldMeaningMnemonic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeaningMnemonic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeaningMnemonic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeaningMnemonic: %w", err)
	}
	return oldValue.MeaningMnemonic, nil
}

// ResetMeaningMnemonic resets all changes to the "meaning_mnemonic" field.
func (m *KanjiMutation) ResetMeaningMnemonic() {
	m.meaning_mnemonic = nil
}

// SetReadingMnemonic sets the "reading_mnemonic" field.
func (m *KanjiMutation) SetReadingMnemonic(s string) {
	m.reading_mnemonic = &s
}

// ReadingMnemonic returns the value of the "reading_mnemonic" field in the mutation.
func (m *KanjiMutation) ReadingMnemonic() (r string, exists bool) {
	v := m.reading_mnemonic
	if v == nil {
		return
	}
	return *v, true
}

// OldReadingMnemonic returns the old "reading_mnemonic" field's value of the Kanji entity.
// If the Kanji object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KanjiMutation) OldReadingMnemonic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadingMnemonic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadingMnemonic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadingMnemonic: %w", err)
	}
	return oldValue.ReadingMnemonic, nil
}

// ResetReadingMnemonic resets all changes to the "reading_mnemonic" field.
func (m *KanjiMutation) ResetReadingMnemonic() {
	m.reading_mnemonic = nil
}

// AddVocabularyIDs adds the "vocabularies" edge to the Vocabulary entity by ids.
func (m *KanjiMutation) AddVocabularyIDs(ids ...uuid.UUID) {
	if m.vocabularies == nil {
		m.vocabularies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vocabularies[ids[i]] = struct{}{}
	}
}

// ClearVocabularies clears the "vocabularies" edge to the Vocabulary entity.
func (m *KanjiMutation) ClearVocabularies() {
	m.clearedvocabularies = true
}

// VocabulariesCleared reports if the "vocabularies" edge to the Vocabulary entity was cleared.
func (m *KanjiMutation) VocabulariesCleared() bool {
	return m.clearedvocabularies
}

// RemoveVocabularyIDs removes the "vocabularies" edge to the Vocabulary entity by IDs.
func (m *KanjiMutation) RemoveVocabularyIDs(ids ...uuid.UUID) {
	if m.removedvocabularies == nil {
		m.removedvocabularies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vocabularies, ids[i])
		m.removedvocabularies[ids[i]] = struct{}{}
	}
}

// RemovedVocabularies returns the removed IDs of the "vocabularies" edge to the Vocabulary entity.
func (m *KanjiMutation) RemovedVocabulariesIDs() (ids []uuid.UUID) {
	for id := range m.removedvocabularies {
		ids = append(ids, id)
	}
	return
}

// VocabulariesIDs returns the "vocabularies" edge IDs in the mutation.
func (m *KanjiMutation) VocabulariesIDs() (ids []uuid.UUID) {
	for id := range m.vocabularies {
		ids = append(ids, id)
	}
	return
}

// ResetVocabularies resets all changes to the "vocabularies" edge.
func (m *KanjiMutation) ResetVocabularies() {
	m.vocabularies = nil
	m.clearedvocabularies = false
	m.removedvocabularies = nil
}

// AddRadicalIDs adds the "radicals" edge to the Radical entity by ids.
func (m *KanjiMutation) AddRadicalIDs(ids ...uuid.UUID) {
	if m.radicals == nil {
		m.radicals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.radicals[ids[i]] = struct{}{}
	}
}

// ClearRadicals clears the "radicals" edge to the Radical entity.
func (m *KanjiMutation) ClearRadicals() {
	m.clearedradicals = true
}

// RadicalsCleared reports if the "radicals" edge to the Radical entity was cleared.
func (m *KanjiMutation) RadicalsCleared() bool {
	return m.clearedradicals
}

// RemoveRadicalIDs removes the "radicals" edge to the Radical entity by IDs.
func (m *KanjiMutation) RemoveRadicalIDs(ids ...uuid.UUID) {
	if m.removedradicals == nil {
		m.removedradicals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.radicals, ids[i])
		m.removedradicals[ids[i]] = struct{}{}
	}
}

// RemovedRadicals returns the removed IDs of the "radicals" edge to the Radical entity.
func (m *KanjiMutation) RemovedRadicalsIDs() (ids []uuid.UUID) {
	for id := range m.removedradicals {
		ids = append(ids, id)
	}
	return
}

// RadicalsIDs returns the "radicals" edge IDs in the mutation.
func (m *KanjiMutation) RadicalsIDs() (ids []uuid.UUID) {
	for id := range m.radicals {
		ids = append(ids, id)
	}
	return
}

// ResetRadicals resets all changes to the "radicals" edge.
func (m *KanjiMutation) ResetRadicals() {
	m.radicals = nil
	m.clearedradicals = false
	m.removedradicals = nil
}

// Where appends a list predicates to the KanjiMutation builder.
func (m *KanjiMutation) Where(ps ...predicate.Kanji) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *KanjiMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Kanji).
func (m *KanjiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KanjiMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, kanji.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kanji.FieldUpdatedAt)
	}
	if m.symbol != nil {
		fields = append(fields, kanji.FieldSymbol)
	}
	if m.name != nil {
		fields = append(fields, kanji.FieldName)
	}
	if m.alt_names != nil {
		fields = append(fields, kanji.FieldAltNames)
	}
	if m.similar != nil {
		fields = append(fields, kanji.FieldSimilar)
	}
	if m.level != nil {
		fields = append(fields, kanji.FieldLevel)
	}
	if m.reading != nil {
		fields = append(fields, kanji.FieldReading)
	}
	if m.onyomi != nil {
		fields = append(fields, kanji.FieldOnyomi)
	}
	if m.kunyomi != nil {
		fields = append(fields, kanji.FieldKunyomi)
	}
	if m.nanori != nil {
		fields = append(fields, kanji.FieldNanori)
	}
	if m.meaning_mnemonic != nil {
		fields = append(fields, kanji.FieldMeaningMnemonic)
	}
	if m.reading_mnemonic != nil {
		fields = append(fields, kanji.FieldReadingMnemonic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KanjiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kanji.FieldCreatedAt:
		return m.CreatedAt()
	case kanji.FieldUpdatedAt:
		return m.UpdatedAt()
	case kanji.FieldSymbol:
		return m.Symbol()
	case kanji.FieldName:
		return m.Name()
	case kanji.FieldAltNames:
		return m.AltNames()
	case kanji.FieldSimilar:
		return m.Similar()
	case kanji.FieldLevel:
		return m.Level()
	case kanji.FieldReading:
		return m.Reading()
	case kanji.FieldOnyomi:
		return m.Onyomi()
	case kanji.FieldKunyomi:
		return m.Kunyomi()
	case kanji.FieldNanori:
		return m.Nanori()
	case kanji.FieldMeaningMnemonic:
		return m.MeaningMnemonic()
	case kanji.FieldReadingMnemonic:
		return m.ReadingMnemonic()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KanjiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kanji.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kanji.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kanji.FieldSymbol:
		return m.OldSymbol(ctx)
	case kanji.FieldName:
		return m.OldName(ctx)
	case kanji.FieldAltNames:
		return m.OldAltNames(ctx)
	case kanji.FieldSimilar:
		return m.OldSimilar(ctx)
	case kanji.FieldLevel:
		return m.OldLevel(ctx)
	case kanji.FieldReading:
		return m.OldReading(ctx)
	case kanji.FieldOnyomi:
		return m.OldOnyomi(ctx)
	case kanji.FieldKunyomi:
		return m.OldKunyomi(ctx)
	case kanji.FieldNanori:
		return m.OldNanori(ctx)
	case kanji.FieldMeaningMnemonic:
		return m.OldMeaningMnemonic(ctx)
	case kanji.FieldReadingMnemonic:
		return m.OldReadingMnemonic(ctx)
	}
	return nil, fmt.Errorf("unknown Kanji field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KanjiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kanji.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kanji.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kanji.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case kanji.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case kanji.FieldAltNames:
		v, ok := value.(pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltNames(v)
		return nil
	case kanji.FieldSimilar:
		v, ok := value.(pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimilar(v)
		return nil
	case kanji.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case kanji.FieldReading:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReading(v)
		return nil
	case kanji.FieldOnyomi:
		v, ok := value.(pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnyomi(v)
		return nil
	case kanji.FieldKunyomi:
		v, ok := value.(pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKunyomi(v)
		return nil
	case kanji.FieldNanori:
		v, ok := value.(pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNanori(v)
		return nil
	case kanji.FieldMeaningMnemonic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeaningMnemonic(v)
		return nil
	case kanji.FieldReadingMnemonic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadingMnemonic(v)
		return nil
	}
	return fmt.Errorf("unknown Kanji field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KanjiMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, kanji.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KanjiMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kanji.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KanjiMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kanji.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Kanji numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KanjiMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kanji.FieldAltNames) {
		fields = append(fields, kanji.FieldAltNames)
	}
	if m.FieldCleared(kanji.FieldSimilar) {
		fields = append(fields, kanji.FieldSimilar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KanjiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KanjiMutation) ClearField(name string) error {
	switch name {
	case kanji.FieldAltNames:
		m.ClearAltNames()
		return nil
	case kanji.FieldSimilar:
		m.ClearSimilar()
		return nil
	}
	return fmt.Errorf("unknown Kanji nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KanjiMutation) ResetField(name string) error {
	switch name {
	case kanji.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kanji.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kanji.FieldSymbol:
		m.ResetSymbol()
		return nil
	case kanji.FieldName:
		m.ResetName()
		return nil
	case kanji.FieldAltNames:
		m.ResetAltNames()
		return nil
	case kanji.FieldSimilar:
		m.ResetSimilar()
		return nil
	case kanji.FieldLevel:
		m.ResetLevel()
		return nil
	case kanji.FieldReading:
		m.ResetReading()
		return nil
	case kanji.FieldOnyomi:
		m.ResetOnyomi()
		return nil
	case kanji.FieldKunyomi:
		m.ResetKunyomi()
		return nil
	case kanji.FieldNanori:
		m.ResetNanori()
		return nil
	case kanji.FieldMeaningMnemonic:
		m.ResetMeaningMnemonic()
		return nil
	case kanji.FieldReadingMnemonic:
		m.ResetReadingMnemonic()
		return nil
	}
	return fmt.Errorf("unknown Kanji field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KanjiMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.vocabularies != nil {
		edges = append(edges, kanji.EdgeVocabularies)
	}
	if m.radicals != nil {
		edges = append(edges, kanji.EdgeRadicals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KanjiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kanji.EdgeVocabularies:
		ids := make([]ent.Value, 0, len(m.vocabularies))
		for id := range m.vocabularies {
			ids = append(ids, id)
		}
		return ids
	case kanji.EdgeRadicals:
		ids := make([]ent.Value, 0, len(m.radicals))
		for id := range m.radicals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KanjiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvocabularies != nil {
		edges = append(edges, kanji.EdgeVocabularies)
	}
	if m.removedradicals != nil {
		edges = append(edges, kanji.EdgeRadicals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KanjiMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kanji.EdgeVocabularies:
		ids := make([]ent.Value, 0, len(m.removedvocabularies))
		for id := range m.removedvocabularies {
			ids = append(ids, id)
		}
		return ids
	case kanji.EdgeRadicals:
		ids := make([]ent.Value, 0, len(m.removedradicals))
		for id := range m.removedradicals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KanjiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvocabularies {
		edges = append(edges, kanji.EdgeVocabularies)
	}
	if m.clearedradicals {
		edges = append(edges, kanji.EdgeRadicals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KanjiMutation) EdgeCleared(name string) bool {
	switch name {
	case kanji.EdgeVocabularies:
		return m.clearedvocabularies
	case kanji.EdgeRadicals:
		return m.clearedradicals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KanjiMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Kanji unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KanjiMutation) ResetEdge(name string) error {
	switch name {
	case kanji.EdgeVocabularies:
		m.ResetVocabularies()
		return nil
	case kanji.EdgeRadicals:
		m.ResetRadicals()
		return nil
	}
	return fmt.Errorf("unknown Kanji edge %s", name)
}

// RadicalMutation represents an operation that mutates the Radical nodes in the graph.
type RadicalMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	level            *int32
	addlevel         *int32
	symbol           *string
	meaning_mnemonic *string
	clearedFields    map[string]struct{}
	kanjis           map[uuid.UUID]struct{}
	removedkanjis    map[uuid.UUID]struct{}
	clearedkanjis    bool
	done             bool
	oldValue         func(context.Context) (*Radical, error)
	predicates       []predicate.Radical
}

var _ ent.Mutation = (*RadicalMutation)(nil)

// radicalOption allows management of the mutation configuration using functional options.
type radicalOption func(*RadicalMutation)

// newRadicalMutation creates new mutation for the Radical entity.
func newRadicalMutation(c config, op Op, opts ...radicalOption) *RadicalMutation {
	m := &RadicalMutation{
		config:        c,
		op:            op,
		typ:           TypeRadical,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRadicalID sets the ID field of the mutation.
func withRadicalID(id uuid.UUID) radicalOption {
	return func(m *RadicalMutation) {
		var (
			err   error
			once  sync.Once
			value *Radical
		)
		m.oldValue = func(ctx context.Context) (*Radical, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Radical.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRadical sets the old Radical of the mutation.
func withRadical(node *Radical) radicalOption {
	return func(m *RadicalMutation) {
		m.oldValue = func(context.Context) (*Radical, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RadicalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RadicalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Radical entities.
func (m *RadicalMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RadicalMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RadicalMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Radical.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RadicalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RadicalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Radical entity.
// If the Radical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RadicalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RadicalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RadicalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RadicalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Radical entity.
// If the Radical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RadicalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RadicalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RadicalMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RadicalMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Radical entity.
// If the Radical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RadicalMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RadicalMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *RadicalMutation) SetLevel(i int32) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *RadicalMutation) Level() (r int32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Radical entity.
// If the Radical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RadicalMutation) OldLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *RadicalMutation) AddLevel(i int32) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *RadicalMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *RadicalMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetSymbol sets the "symbol" field.
func (m *RadicalMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *RadicalMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Radical entity.
// If the Radical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RadicalMutation) OldSymbol(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *RadicalMutation) ResetSymbol() {
	m.symbol = nil
}

// SetMeaningMnemonic sets the "meaning_mnemonic" field.
func (m *RadicalMutation) SetMeaningMnemonic(s string) {
	m.meaning_mnemonic = &s
}

// MeaningMnemonic returns the value of the "meaning_mnemonic" field in the mutation.
func (m *RadicalMutation) MeaningMnemonic() (r string, exists bool) {
	v := m.meaning_mnemonic
	if v == nil {
		return
	}
	return *v, true
}

// OldMeaningMnemonic returns the old "meaning_mnemonic" field's value of the Radical entity.
// If the Radical object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RadicalMutation) OldMeaningMnemonic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeaningMnemonic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeaningMnemonic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeaningMnemonic: %w", err)
	}
	return oldValue.MeaningMnemonic, nil
}

// ResetMeaningMnemonic resets all changes to the "meaning_mnemonic" field.
func (m *RadicalMutation) ResetMeaningMnemonic() {
	m.meaning_mnemonic = nil
}

// AddKanjiIDs adds the "kanjis" edge to the Kanji entity by ids.
func (m *RadicalMutation) AddKanjiIDs(ids ...uuid.UUID) {
	if m.kanjis == nil {
		m.kanjis = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.kanjis[ids[i]] = struct{}{}
	}
}

// ClearKanjis clears the "kanjis" edge to the Kanji entity.
func (m *RadicalMutation) ClearKanjis() {
	m.clearedkanjis = true
}

// KanjisCleared reports if the "kanjis" edge to the Kanji entity was cleared.
func (m *RadicalMutation) KanjisCleared() bool {
	return m.clearedkanjis
}

// RemoveKanjiIDs removes the "kanjis" edge to the Kanji entity by IDs.
func (m *RadicalMutation) RemoveKanjiIDs(ids ...uuid.UUID) {
	if m.removedkanjis == nil {
		m.removedkanjis = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.kanjis, ids[i])
		m.removedkanjis[ids[i]] = struct{}{}
	}
}

// RemovedKanjis returns the removed IDs of the "kanjis" edge to the Kanji entity.
func (m *RadicalMutation) RemovedKanjisIDs() (ids []uuid.UUID) {
	for id := range m.removedkanjis {
		ids = append(ids, id)
	}
	return
}

// KanjisIDs returns the "kanjis" edge IDs in the mutation.
func (m *RadicalMutation) KanjisIDs() (ids []uuid.UUID) {
	for id := range m.kanjis {
		ids = append(ids, id)
	}
	return
}

// ResetKanjis resets all changes to the "kanjis" edge.
func (m *RadicalMutation) ResetKanjis() {
	m.kanjis = nil
	m.clearedkanjis = false
	m.removedkanjis = nil
}

// Where appends a list predicates to the RadicalMutation builder.
func (m *RadicalMutation) Where(ps ...predicate.Radical) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RadicalMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Radical).
func (m *RadicalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RadicalMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, radical.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, radical.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, radical.FieldName)
	}
	if m.level != nil {
		fields = append(fields, radical.FieldLevel)
	}
	if m.symbol != nil {
		fields = append(fields, radical.FieldSymbol)
	}
	if m.meaning_mnemonic != nil {
		fields = append(fields, radical.FieldMeaningMnemonic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RadicalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case radical.FieldCreatedAt:
		return m.CreatedAt()
	case radical.FieldUpdatedAt:
		return m.UpdatedAt()
	case radical.FieldName:
		return m.Name()
	case radical.FieldLevel:
		return m.Level()
	case radical.FieldSymbol:
		return m.Symbol()
	case radical.FieldMeaningMnemonic:
		return m.MeaningMnemonic()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RadicalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case radical.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case radical.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case radical.FieldName:
		return m.OldName(ctx)
	case radical.FieldLevel:
		return m.OldLevel(ctx)
	case radical.FieldSymbol:
		return m.OldSymbol(ctx)
	case radical.FieldMeaningMnemonic:
		return m.OldMeaningMnemonic(ctx)
	}
	return nil, fmt.Errorf("unknown Radical field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RadicalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case radical.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case radical.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case radical.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case radical.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case radical.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case radical.FieldMeaningMnemonic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeaningMnemonic(v)
		return nil
	}
	return fmt.Errorf("unknown Radical field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RadicalMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, radical.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RadicalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case radical.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RadicalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case radical.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Radical numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RadicalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RadicalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RadicalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Radical nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RadicalMutation) ResetField(name string) error {
	switch name {
	case radical.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case radical.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case radical.FieldName:
		m.ResetName()
		return nil
	case radical.FieldLevel:
		m.ResetLevel()
		return nil
	case radical.FieldSymbol:
		m.ResetSymbol()
		return nil
	case radical.FieldMeaningMnemonic:
		m.ResetMeaningMnemonic()
		return nil
	}
	return fmt.Errorf("unknown Radical field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RadicalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.kanjis != nil {
		edges = append(edges, radical.EdgeKanjis)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RadicalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case radical.EdgeKanjis:
		ids := make([]ent.Value, 0, len(m.kanjis))
		for id := range m.kanjis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RadicalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedkanjis != nil {
		edges = append(edges, radical.EdgeKanjis)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RadicalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case radical.EdgeKanjis:
		ids := make([]ent.Value, 0, len(m.removedkanjis))
		for id := range m.removedkanjis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RadicalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedkanjis {
		edges = append(edges, radical.EdgeKanjis)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RadicalMutation) EdgeCleared(name string) bool {
	switch name {
	case radical.EdgeKanjis:
		return m.clearedkanjis
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RadicalMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Radical unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RadicalMutation) ResetEdge(name string) error {
	switch name {
	case radical.EdgeKanjis:
		m.ResetKanjis()
		return nil
	}
	return fmt.Errorf("unknown Radical edge %s", name)
}

// VocabularyMutation represents an operation that mutates the Vocabulary nodes in the graph.
type VocabularyMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	alt_names        *pgtype.TextArray
	level            *int32
	addlevel         *int32
	word             *string
	word_type        *pgtype.TextArray
	reading          *string
	alt_readings     *pgtype.TextArray
	patterns         *[]schema.Pattern
	appendpatterns   []schema.Pattern
	sentences        *[]schema.Sentence
	appendsentences  []schema.Sentence
	meaning_mnemonic *string
	reading_mnemonic *string
	clearedFields    map[string]struct{}
	kanjis           map[uuid.UUID]struct{}
	removedkanjis    map[uuid.UUID]struct{}
	clearedkanjis    bool
	done             bool
	oldValue         func(context.Context) (*Vocabulary, error)
	predicates       []predicate.Vocabulary
}

var _ ent.Mutation = (*VocabularyMutation)(nil)

// vocabularyOption allows management of the mutation configuration using functional options.
type vocabularyOption func(*VocabularyMutation)

// newVocabularyMutation creates new mutation for the Vocabulary entity.
func newVocabularyMutation(c config, op Op, opts ...vocabularyOption) *VocabularyMutation {
	m := &VocabularyMutation{
		config:        c,
		op:            op,
		typ:           TypeVocabulary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVocabularyID sets the ID field of the mutation.
func withVocabularyID(id uuid.UUID) vocabularyOption {
	return func(m *VocabularyMutation) {
		var (
			err   error
			once  sync.Once
			value *Vocabulary
		)
		m.oldValue = func(ctx context.Context) (*Vocabulary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vocabulary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVocabulary sets the old Vocabulary of the mutation.
func withVocabulary(node *Vocabulary) vocabularyOption {
	return func(m *VocabularyMutation) {
		m.oldValue = func(context.Context) (*Vocabulary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VocabularyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VocabularyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vocabulary entities.
func (m *VocabularyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VocabularyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VocabularyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vocabulary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VocabularyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VocabularyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VocabularyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VocabularyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VocabularyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VocabularyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *VocabularyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VocabularyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VocabularyMutation) ResetName() {
	m.name = nil
}

// SetAltNames sets the "alt_names" field.
func (m *VocabularyMutation) SetAltNames(pa pgtype.TextArray) {
	m.alt_names = &pa
}

// AltNames returns the value of the "alt_names" field in the mutation.
func (m *VocabularyMutation) AltNames() (r pgtype.TextArray, exists bool) {
	v := m.alt_names
	if v == nil {
		return
	}
	return *v, true
}

// OldAltNames returns the old "alt_names" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldAltNames(ctx context.Context) (v pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltNames: %w", err)
	}
	return oldValue.AltNames, nil
}

// ClearAltNames clears the value of the "alt_names" field.
func (m *VocabularyMutation) ClearAltNames() {
	m.alt_names = nil
	m.clearedFields[vocabulary.FieldAltNames] = struct{}{}
}

// AltNamesCleared returns if the "alt_names" field was cleared in this mutation.
func (m *VocabularyMutation) AltNamesCleared() bool {
	_, ok := m.clearedFields[vocabulary.FieldAltNames]
	return ok
}

// ResetAltNames resets all changes to the "alt_names" field.
func (m *VocabularyMutation) ResetAltNames() {
	m.alt_names = nil
	delete(m.clearedFields, vocabulary.FieldAltNames)
}

// SetLevel sets the "level" field.
func (m *VocabularyMutation) SetLevel(i int32) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *VocabularyMutation) Level() (r int32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *VocabularyMutation) AddLevel(i int32) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *VocabularyMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *VocabularyMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetWord sets the "word" field.
func (m *VocabularyMutation) SetWord(s string) {
	m.word = &s
}

// Word returns the value of the "word" field in the mutation.
func (m *VocabularyMutation) Word() (r string, exists bool) {
	v := m.word
	if v == nil {
		return
	}
	return *v, true
}

// OldWord returns the old "word" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldWord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWord: %w", err)
	}
	return oldValue.Word, nil
}

// ResetWord resets all changes to the "word" field.
func (m *VocabularyMutation) ResetWord() {
	m.word = nil
}

// SetWordType sets the "word_type" field.
func (m *VocabularyMutation) SetWordType(pa pgtype.TextArray) {
	m.word_type = &pa
}

// WordType returns the value of the "word_type" field in the mutation.
func (m *VocabularyMutation) WordType() (r pgtype.TextArray, exists bool) {
	v := m.word_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWordType returns the old "word_type" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldWordType(ctx context.Context) (v pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordType: %w", err)
	}
	return oldValue.WordType, nil
}

// ResetWordType resets all changes to the "word_type" field.
func (m *VocabularyMutation) ResetWordType() {
	m.word_type = nil
}

// SetReading sets the "reading" field.
func (m *VocabularyMutation) SetReading(s string) {
	m.reading = &s
}

// Reading returns the value of the "reading" field in the mutation.
func (m *VocabularyMutation) Reading() (r string, exists bool) {
	v := m.reading
	if v == nil {
		return
	}
	return *v, true
}

// OldReading returns the old "reading" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldReading(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReading is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReading requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReading: %w", err)
	}
	return oldValue.Reading, nil
}

// ResetReading resets all changes to the "reading" field.
func (m *VocabularyMutation) ResetReading() {
	m.reading = nil
}

// SetAltReadings sets the "alt_readings" field.
func (m *VocabularyMutation) SetAltReadings(pa pgtype.TextArray) {
	m.alt_readings = &pa
}

// AltReadings returns the value of the "alt_readings" field in the mutation.
func (m *VocabularyMutation) AltReadings() (r pgtype.TextArray, exists bool) {
	v := m.alt_readings
	if v == nil {
		return
	}
	return *v, true
}

// OldAltReadings returns the old "alt_readings" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldAltReadings(ctx context.Context) (v pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltReadings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltReadings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltReadings: %w", err)
	}
	return oldValue.AltReadings, nil
}

// ClearAltReadings clears the value of the "alt_readings" field.
func (m *VocabularyMutation) ClearAltReadings() {
	m.alt_readings = nil
	m.clearedFields[vocabulary.FieldAltReadings] = struct{}{}
}

// AltReadingsCleared returns if the "alt_readings" field was cleared in this mutation.
func (m *VocabularyMutation) AltReadingsCleared() bool {
	_, ok := m.clearedFields[vocabulary.FieldAltReadings]
	return ok
}

// ResetAltReadings resets all changes to the "alt_readings" field.
func (m *VocabularyMutation) ResetAltReadings() {
	m.alt_readings = nil
	delete(m.clearedFields, vocabulary.FieldAltReadings)
}

// SetPatterns sets the "patterns" field.
func (m *VocabularyMutation) SetPatterns(s []schema.Pattern) {
	m.patterns = &s
	m.appendpatterns = nil
}

// Patterns returns the value of the "patterns" field in the mutation.
func (m *VocabularyMutation) Patterns() (r []schema.Pattern, exists bool) {
	v := m.patterns
	if v == nil {
		return
	}
	return *v, true
}

// OldPatterns returns the old "patterns" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldPatterns(ctx context.Context) (v []schema.Pattern, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatterns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatterns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatterns: %w", err)
	}
	return oldValue.Patterns, nil
}

// AppendPatterns adds s to the "patterns" field.
func (m *VocabularyMutation) AppendPatterns(s []schema.Pattern) {
	m.appendpatterns = append(m.appendpatterns, s...)
}

// AppendedPatterns returns the list of values that were appended to the "patterns" field in this mutation.
func (m *VocabularyMutation) AppendedPatterns() ([]schema.Pattern, bool) {
	if len(m.appendpatterns) == 0 {
		return nil, false
	}
	return m.appendpatterns, true
}

// ResetPatterns resets all changes to the "patterns" field.
func (m *VocabularyMutation) ResetPatterns() {
	m.patterns = nil
	m.appendpatterns = nil
}

// SetSentences sets the "sentences" field.
func (m *VocabularyMutation) SetSentences(s []schema.Sentence) {
	m.sentences = &s
	m.appendsentences = nil
}

// Sentences returns the value of the "sentences" field in the mutation.
func (m *VocabularyMutation) Sentences() (r []schema.Sentence, exists bool) {
	v := m.sentences
	if v == nil {
		return
	}
	return *v, true
}

// OldSentences returns the old "sentences" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldSentences(ctx context.Context) (v []schema.Sentence, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentences: %w", err)
	}
	return oldValue.Sentences, nil
}

// AppendSentences adds s to the "sentences" field.
func (m *VocabularyMutation) AppendSentences(s []schema.Sentence) {
	m.appendsentences = append(m.appendsentences, s...)
}

// AppendedSentences returns the list of values that were appended to the "sentences" field in this mutation.
func (m *VocabularyMutation) AppendedSentences() ([]schema.Sentence, bool) {
	if len(m.appendsentences) == 0 {
		return nil, false
	}
	return m.appendsentences, true
}

// ResetSentences resets all changes to the "sentences" field.
func (m *VocabularyMutation) ResetSentences() {
	m.sentences = nil
	m.appendsentences = nil
}

// SetMeaningMnemonic sets the "meaning_mnemonic" field.
func (m *VocabularyMutation) SetMeaningMnemonic(s string) {
	m.meaning_mnemonic = &s
}

// MeaningMnemonic returns the value of the "meaning_mnemonic" field in the mutation.
func (m *VocabularyMutation) MeaningMnemonic() (r string, exists bool) {
	v := m.meaning_mnemonic
	if v == nil {
		return
	}
	return *v, true
}

// OldMeaningMnemonic returns the old "meaning_mnemonic" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldMeaningMnemonic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeaningMnemonic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeaningMnemonic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeaningMnemonic: %w", err)
	}
	return oldValue.MeaningMnemonic, nil
}

// ResetMeaningMnemonic resets all changes to the "meaning_mnemonic" field.
func (m *VocabularyMutation) ResetMeaningMnemonic() {
	m.meaning_mnemonic = nil
}

// SetReadingMnemonic sets the "reading_mnemonic" field.
func (m *VocabularyMutation) SetReadingMnemonic(s string) {
	m.reading_mnemonic = &s
}

// ReadingMnemonic returns the value of the "reading_mnemonic" field in the mutation.
func (m *VocabularyMutation) ReadingMnemonic() (r string, exists bool) {
	v := m.reading_mnemonic
	if v == nil {
		return
	}
	return *v, true
}

// OldReadingMnemonic returns the old "reading_mnemonic" field's value of the Vocabulary entity.
// If the Vocabulary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VocabularyMutation) OldReadingMnemonic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadingMnemonic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadingMnemonic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadingMnemonic: %w", err)
	}
	return oldValue.ReadingMnemonic, nil
}

// ResetReadingMnemonic resets all changes to the "reading_mnemonic" field.
func (m *VocabularyMutation) ResetReadingMnemonic() {
	m.reading_mnemonic = nil
}

// AddKanjiIDs adds the "kanjis" edge to the Kanji entity by ids.
func (m *VocabularyMutation) AddKanjiIDs(ids ...uuid.UUID) {
	if m.kanjis == nil {
		m.kanjis = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.kanjis[ids[i]] = struct{}{}
	}
}

// ClearKanjis clears the "kanjis" edge to the Kanji entity.
func (m *VocabularyMutation) ClearKanjis() {
	m.clearedkanjis = true
}

// KanjisCleared reports if the "kanjis" edge to the Kanji entity was cleared.
func (m *VocabularyMutation) KanjisCleared() bool {
	return m.clearedkanjis
}

// RemoveKanjiIDs removes the "kanjis" edge to the Kanji entity by IDs.
func (m *VocabularyMutation) RemoveKanjiIDs(ids ...uuid.UUID) {
	if m.removedkanjis == nil {
		m.removedkanjis = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.kanjis, ids[i])
		m.removedkanjis[ids[i]] = struct{}{}
	}
}

// RemovedKanjis returns the removed IDs of the "kanjis" edge to the Kanji entity.
func (m *VocabularyMutation) RemovedKanjisIDs() (ids []uuid.UUID) {
	for id := range m.removedkanjis {
		ids = append(ids, id)
	}
	return
}

// KanjisIDs returns the "kanjis" edge IDs in the mutation.
func (m *VocabularyMutation) KanjisIDs() (ids []uuid.UUID) {
	for id := range m.kanjis {
		ids = append(ids, id)
	}
	return
}

// ResetKanjis resets all changes to the "kanjis" edge.
func (m *VocabularyMutation) ResetKanjis() {
	m.kanjis = nil
	m.clearedkanjis = false
	m.removedkanjis = nil
}

// Where appends a list predicates to the VocabularyMutation builder.
func (m *VocabularyMutation) Where(ps ...predicate.Vocabulary) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VocabularyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vocabulary).
func (m *VocabularyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VocabularyMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, vocabulary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vocabulary.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, vocabulary.FieldName)
	}
	if m.alt_names != nil {
		fields = append(fields, vocabulary.FieldAltNames)
	}
	if m.level != nil {
		fields = append(fields, vocabulary.FieldLevel)
	}
	if m.word != nil {
		fields = append(fields, vocabulary.FieldWord)
	}
	if m.word_type != nil {
		fields = append(fields, vocabulary.FieldWordType)
	}
	if m.reading != nil {
		fields = append(fields, vocabulary.FieldReading)
	}
	if m.alt_readings != nil {
		fields = append(fields, vocabulary.FieldAltReadings)
	}
	if m.patterns != nil {
		fields = append(fields, vocabulary.FieldPatterns)
	}
	if m.sentences != nil {
		fields = append(fields, vocabulary.FieldSentences)
	}
	if m.meaning_mnemonic != nil {
		fields = append(fields, vocabulary.FieldMeaningMnemonic)
	}
	if m.reading_mnemonic != nil {
		fields = append(fields, vocabulary.FieldReadingMnemonic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VocabularyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vocabulary.FieldCreatedAt:
		return m.CreatedAt()
	case vocabulary.FieldUpdatedAt:
		return m.UpdatedAt()
	case vocabulary.FieldName:
		return m.Name()
	case vocabulary.FieldAltNames:
		return m.AltNames()
	case vocabulary.FieldLevel:
		return m.Level()
	case vocabulary.FieldWord:
		return m.Word()
	case vocabulary.FieldWordType:
		return m.WordType()
	case vocabulary.FieldReading:
		return m.Reading()
	case vocabulary.FieldAltReadings:
		return m.AltReadings()
	case vocabulary.FieldPatterns:
		return m.Patterns()
	case vocabulary.FieldSentences:
		return m.Sentences()
	case vocabulary.FieldMeaningMnemonic:
		return m.MeaningMnemonic()
	case vocabulary.FieldReadingMnemonic:
		return m.ReadingMnemonic()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VocabularyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vocabulary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vocabulary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vocabulary.FieldName:
		return m.OldName(ctx)
	case vocabulary.FieldAltNames:
		return m.OldAltNames(ctx)
	case vocabulary.FieldLevel:
		return m.OldLevel(ctx)
	case vocabulary.FieldWord:
		return m.OldWord(ctx)
	case vocabulary.FieldWordType:
		return m.OldWordType(ctx)
	case vocabulary.FieldReading:
		return m.OldReading(ctx)
	case vocabulary.FieldAltReadings:
		return m.OldAltReadings(ctx)
	case vocabulary.FieldPatterns:
		return m.OldPatterns(ctx)
	case vocabulary.FieldSentences:
		return m.OldSentences(ctx)
	case vocabulary.FieldMeaningMnemonic:
		return m.OldMeaningMnemonic(ctx)
	case vocabulary.FieldReadingMnemonic:
		return m.OldReadingMnemonic(ctx)
	}
	return nil, fmt.Errorf("unknown Vocabulary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VocabularyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vocabulary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vocabulary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vocabulary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vocabulary.FieldAltNames:
		v, ok := value.(pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltNames(v)
		return nil
	case vocabulary.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case vocabulary.FieldWord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWord(v)
		return nil
	case vocabulary.FieldWordType:
		v, ok := value.(pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordType(v)
		return nil
	case vocabulary.FieldReading:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReading(v)
		return nil
	case vocabulary.FieldAltReadings:
		v, ok := value.(pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltReadings(v)
		return nil
	case vocabulary.FieldPatterns:
		v, ok := value.([]schema.Pattern)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatterns(v)
		return nil
	case vocabulary.FieldSentences:
		v, ok := value.([]schema.Sentence)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentences(v)
		return nil
	case vocabulary.FieldMeaningMnemonic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeaningMnemonic(v)
		return nil
	case vocabulary.FieldReadingMnemonic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadingMnemonic(v)
		return nil
	}
	return fmt.Errorf("unknown Vocabulary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VocabularyMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, vocabulary.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VocabularyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vocabulary.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VocabularyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vocabulary.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Vocabulary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VocabularyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vocabulary.FieldAltNames) {
		fields = append(fields, vocabulary.FieldAltNames)
	}
	if m.FieldCleared(vocabulary.FieldAltReadings) {
		fields = append(fields, vocabulary.FieldAltReadings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VocabularyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VocabularyMutation) ClearField(name string) error {
	switch name {
	case vocabulary.FieldAltNames:
		m.ClearAltNames()
		return nil
	case vocabulary.FieldAltReadings:
		m.ClearAltReadings()
		return nil
	}
	return fmt.Errorf("unknown Vocabulary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VocabularyMutation) ResetField(name string) error {
	switch name {
	case vocabulary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vocabulary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vocabulary.FieldName:
		m.ResetName()
		return nil
	case vocabulary.FieldAltNames:
		m.ResetAltNames()
		return nil
	case vocabulary.FieldLevel:
		m.ResetLevel()
		return nil
	case vocabulary.FieldWord:
		m.ResetWord()
		return nil
	case vocabulary.FieldWordType:
		m.ResetWordType()
		return nil
	case vocabulary.FieldReading:
		m.ResetReading()
		return nil
	case vocabulary.FieldAltReadings:
		m.ResetAltReadings()
		return nil
	case vocabulary.FieldPatterns:
		m.ResetPatterns()
		return nil
	case vocabulary.FieldSentences:
		m.ResetSentences()
		return nil
	case vocabulary.FieldMeaningMnemonic:
		m.ResetMeaningMnemonic()
		return nil
	case vocabulary.FieldReadingMnemonic:
		m.ResetReadingMnemonic()
		return nil
	}
	return fmt.Errorf("unknown Vocabulary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VocabularyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.kanjis != nil {
		edges = append(edges, vocabulary.EdgeKanjis)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VocabularyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vocabulary.EdgeKanjis:
		ids := make([]ent.Value, 0, len(m.kanjis))
		for id := range m.kanjis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VocabularyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedkanjis != nil {
		edges = append(edges, vocabulary.EdgeKanjis)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VocabularyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vocabulary.EdgeKanjis:
		ids := make([]ent.Value, 0, len(m.removedkanjis))
		for id := range m.removedkanjis {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VocabularyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedkanjis {
		edges = append(edges, vocabulary.EdgeKanjis)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VocabularyMutation) EdgeCleared(name string) bool {
	switch name {
	case vocabulary.EdgeKanjis:
		return m.clearedkanjis
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VocabularyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Vocabulary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VocabularyMutation) ResetEdge(name string) error {
	switch name {
	case vocabulary.EdgeKanjis:
		m.ResetKanjis()
		return nil
	}
	return fmt.Errorf("unknown Vocabulary edge %s", name)
}
